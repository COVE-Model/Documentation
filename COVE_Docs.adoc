= COVE: Coastal Vector Evolution Model
Martin D. Hurst <Martin.Hurst@glasgow.ac.uk>, Andrew Barkwith, Christopher W. Thomas, Michael A. Ellis, A. Brad Murray
:toc: left
:stem: latexmath
:imagesdir: ./images/
:numbered:
:source-highlighter: coderay

image::COVE_logo.png[width="100", height="100"]

== Introduction

This is the documentation for COVE, the COastal Vector Evolution model - a vector-based one-line coastal evolution model. The model was presented and used in a http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[paper] on the evolution of crenulate bays published in the _Journal of Geophysical Research Earth Surface_ (http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al., 2015]). The model is intended for research purposes, exploring coastal behaviour and sensitiviy. 

The model is intended for research purposes. It is released under a http://www.gnu.org/licenses/gpl-3.0.en.html[GNU General Public Licence]. If you are interested in working with COVE, we would encourage you to mailto:martin.hurst@glasgow.ac.uk[get in touch] and work with us. In this introduction, we will give a brief overview of the science behind the model.

Reference documentation for the code has been generated using Doxygen and the resulting reference material can be accessed at https://COVE-model.github.io/COVE/documentation/html/index.html[COVE Doxygen Documentation].

*SUMMARY*
====
- COVE is a ‘one-line’ type shoreline evolution model.
- Application at spatial scales of kms to tens of kms, over decadal to millennial timescales.
- Coastal change is driven by gradients in wave-generated alongshore sediment transport.
- Alongshore sediment transport driven by the height and angle of breaking waves.
- Retreat of cliffs governed by beach interaction (protection vs tools).
====

=== Overview

The COVE model is a special case of a ‘one-line’ model designed to handle complex coastline geometries, with high planform curvature shorelines (http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al., 2015]). The shoreline is represented by a single line (or contour) that advances or retreats depending on the net alongshore sediment flux. COVE is now actually a two-line model because a second line representing coastal cliffs interacts with the shoreline, eroding to provide beach sediment. One-line models make a number of simplifying assumptions to conceptualise the coastline allowing the ‘one-line’ representation of the coastline:

*ASSUMPTIONS*
====
1. Short-term cross-shore variations due to storms or rip currents are considered temporary perturbations to the long-term
trajectory of coastal change (i.e. the shoreface recovers rapidly from storm-driven cross-shore transport).
2. The beach profile is thus assumed to maintain a constant time-averaged form (Fig. 1), implying that depth contours are
shore-parallel and therefore allows the coast to be represented by a single contour line.
3. Alongshore sediment transport occurs primarily in the surf zone, and cross-shore sediment transport acts to maintain the
equilibrium shoreface as it advances /retreats.
4. Alongshore sediment flux occurs due to wave action in the surf zone, parameterized by the height and angle of incidence
of breaking waves. Gradients in alongshore transport dictate whether the shoreline advances or retreats.
====

image::shoreface_section.png[title="Change in shoreline position viewed in schematic cross section. Planar beach sloepe extends down to the depth of the shoreface. Shoreface advances or retreats across the shelf",width="300",align="center"]

image::parallel_contours.pdf.png[title="Schematic planform diagram of a coastline with shore-parallel depth contours, as assumed in one-line models",width="300",align="center"]

=== Governing equation

Previous one-line models have cast the conservation of sediment in a gridded cartesian framework, relative to the general orientation of the coastline (the latexmath:[x]-coordinate). The result is that coastal cells are rectangular and either prograde or regress perpendicular to the general orientation of the coastline (the latexmath:[y]-coordinate):

image::rectangular_cells.pdf.png[title="Schematic planform diagram of a coastline with rectilinear cells orientated perpendicular to the general trend of the shoreline, as assumed in one-line models. The shoreline either advances or retreats in the latexmath:[y] direction",width="300",align="center"]

Given the assumption that the evolution of the coastline is driven by gradients in alongshore sediment transport, the conservation equation for this setup (e.g. Ashton and Murray, 2006) states that the change of position of the coast latexmath:[y] is equal to the divergence in alongshore sediment flux latexmath:[Q_{ls}] divided by the shoreface depth latexmath:[D_{sf}]:

latexmath:[\frac{dy}{dt} = \frac{1}{D_{sf}}\left(\frac{dQ_{ls}}{dx}\right)]

However, when the shoreline has high planform curvature, this equation becomes difficult to apply as the principle of conservation of mass is violated. Ashton and Murray (2006) dealt with this problem through the use of a cellular model. Alternatively, it has been proposed to use a local coordinate system (LeBlond, 1972; Kaergaard and Fredsoe, 2013). 

==== Using a local coordinate system

The conservation equation for beach sediment expressed in terms of local coordinates states that the change in position of the shoreline latexmath:[d\eta], perpendicular to the local shoreline orientation latexmath:[s] through time latexmath:[t] is a function of the divergence of alongshore sediment flux latexmath:[Q_{ls}]:

latexmath:[\frac{d\eta}{dt} = f\left(\frac{dQ_{ls}}{ds}\right)]

=== Cell building routine

==== Irregular shoreline cells

The nature of the conservation of mass function is dependent on the geometry of shoreline cells. If we were to use rectilinear cells we would violate mass conservation because the cells would either diverge or converge offshore, depending on the planform curvature of the shoreline (i.e. convex offshore vs concave offshore respectively).

image::mass_balance_errors.png[title="Schematic planform diagram of a coastline where rectilinear cells, orientated perpendicular to the local coastline orientation, are assumed to extend down to the bottom of the shoreface. Some cells diverge where the shoreline is convex-seaward, whilst others overlap where the shoreline is concave.",width="300",align="center"] 

In COVE, coastline cells are not rectilinear, but rather triangular, trapezoidal or polygonal. The change of shoreline position for such cells is calculated by inverting quadratic and cubic equations for the volume of sediment in these cells (see http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al., 2015]). 

==== Cell geometry

Each coastline node has an orientation calculated as the azimuth angle of a vector connecting the two adjacent nodes. Cell edges seperating adjacent cells have an orientation that is perpendicular to imaginary lines between the node of interest and each adjacent node, and they bisect these lines. The cell is thus defined by the cell width at the shoreline latexmath:[W_0], and two angles describing the difference between the cell orientation and the cell boundary orientations latexmath:[\eta_1] and latexmath:[\eta_2] for the upcoast and downcoast boundaries respectively.

image::cell_geometry.png[title="Schematic planform diagram of a coastal cell built from the arrangement of coastal nodes.",width="300",align="center"] 

==== Mesh building algorithm

The model builds coastal cells by projecting offshore the cell edges defined above. The procedure is as follows:
. A priority queue is built so that cells with the largest value of \latexmath:[\eta_1+eta_2] are prioritised.
. Starting with the most acute, cell boundaries are projected offshore until...
.. They intersect, in which case the cell is closed and a new boundary for adjacent cells will be created from the intersection point, and adjacent cells will be added to the priority queue again; or
.. The bottom of the shoreface latexmath:[D_{sf}] is reached and the cell is closed by a straight line across the shoreface defining the bottom of the shoreface.
. The procedure continues until all cells have been meshed.

image::meshing.png[title="Plan view of a shoreline with cells built using the mesh building algorithm. Coastal cells built by projecting cell boundaries seaward until they intersect, starting from the most concave-seaward cell. The order in which cell building proceeds is numbered. When cell boundaries intersect, the mean orientation of contributing cell edges determines the direction in which the projection continues.",width="300",align="center"] 

=== Alongshore Flux
Bulk alongshore sediment flux is driven by waves breaking on the shoreface. Typically in alongshore transport laws, flux depends on the height latexmath:[H_b]
and angle latexmath:[\alpha_b] of breaking waves. For example, in the simplest case of fine/medium sand, COVE uses the CERC equation:

latexmath:[Q_{ls} = K_{ls} H_b^{5\over2} \sin 2\alpha_b]

where latexmath:[K_{ls}] is a transport coefficient. The transport coefficient latexmath:[K_{ls}] may be modified to account for the size of beach material (latexmath:[D_{50}]). Calibration of this coefficient can be made from estimates of bulk alongshore transport or by calibration against a historical record of coastal change (e.g. http://www.earth-surf-dynam.net/2/295/2014/esurf-2-295-2014.html[Barkwith et al. 2014a]).

=== Cliff Erosion

Cliffs are represented in the model as a separate line. The cliffline and coastline interact to determine how wide the beach is locally. Eroded cliff material is provided to the adjacent beach and causes the shoreface to advance. Cliff erosion is controlled by beach width since a wider beach provide energy dissipation and protection from approaching waves. Figure 2 shows a schematic graph of this relationship, as well as a conceptual diagram of the representation and relationship of the cliff and the beach.

image::limber_cliff_retreat.png[title="Schematic illustration of retreating cliff and beach. Relationship between beach width and cliff retreat rate is humped and nonlinear. For thin beaches, cliff retreat increases with beach width due to increased availability of \"tools\" to aid erosion. Wider beaches cause reduced cliff retreat, protecting the cliff by dissipating wave energy (after Limber and Murray, 2011).",width="500",align="center"]

The result is that we can run simlutaions at decadal timescales to explore the interactions between coastal erosion and alongshore sediment dynamics. 

=== Model requirements

==== Data
- The model requires offshore (~10 m water depth) wave data. This can be obtained either from a wave buoy or preferably from distributed coastal area modelling predictions of wave conditions (e.g. http://fvcom.smast.umassd.edu/fvcom/[FVCOM] or http://www.swan.tudelft.nl/[SWAN]).
- The transport coefficient latexmath:[K_{ls}] may be modified to account for the size of beach material (latexmath:[D_{50}]). Calibration of this coefficient can be made from estimates of bulk alongshore transport or by calibration against a historical record of coastal change.
- Historical shoreline positions and legacy wave data allow training of the model to reproduce past geomorphic changes.

==== Boundary Conditions
* Offshore waves (see above).
* Coupling to sediment sources and sinks (e.g. river mouth, estuary).
* Human interaction with the coast (e.g. http://www.earth-surf-dynam.net/2/233/2014/[Barkwith et al. 2014b]):
** Nourishment can be provided to build out the shoreface
** Hard defences represented as immovable, cliffed shoreline
** Groin fields simulated by prescribing a minimum beach width

== Software Requirements

COVE is written in C++, partly for efficiency but also to allow us to take advantage of running ensembles of simulations on UNIX high performance computing (HPC) clusters. The code has been written and tested extensively in a Linux/UNIX environment, and has also been compiled and run on Windows using Code::Blocks, but has not been tested on Mac. So for now, you`re going to need to be/get familiar with working at a command line interface. 

There are a number of software requirements to run the model and visualise the results.
====
* C++ compiler (e.g. GCC: the GNU Compiler Collection)
* Text editor (e.g. gedit, Notepad++)
* Python + Scipy, Numpy and Matplotlib packages
====

=== Linux/UNIX

If you do not already work in Linux or UNIX, then the easiest way to get started would be to use some virtualisation software such as https://www.virtualbox.org/[VirtualBox] or http://www.vmware.com/uk/products/player[VMWare Workstation Player]. VirtualBox is preferable since it is open source and free to use, but there are some minor advantages to using VMWare Player if you become a heavy user. We hope soon to provide a https://www.vagrantup.com/[Vagrant file] to make this process a bit more straight forward. For now, I recommend installing https://www.virtualbox.org/[VirtualBox], creating a new virtual machine, and installing http://www.ubuntu.com/desktop[Ubuntu] using a downloaded iso file.

==== Git

https://git-scm.com/[Git] is version control software. The model is stored in a repository on https://github.com/COVE-Model[github]. This allows us to track all of our updates and developments and avoid duplication. You can install git from the command line:
----
$ sudo apt-get install git
----
Getting to grips with git can be a steep learning curve at first. The https://help.github.com/articles/github-glossary/[github glossary] is useful for getting up to speed with the terminology, and I found a good https://www.git-tower.com/blog/git-cheat-sheet/[cheat sheet] for git commands.
 
==== C++ Compiler

If you are using a Linux machine (e.g. the recommended Ubuntu VM) then you should have the GNU Compiler Collection installed. Depending on your experience and whether your developing the model, the https://www.gnu.org/software/gdb/[GNU debugger] can also be helpful (should already be installed with GCC), not to mention http://valgrind.org/[Valgrind] (you probably know what you`re doing better than I do if you`re using Valgrind!). We will also need the make utility (this should also be ready installed). No additional C++ libraries are required at this stage.

==== Text editor

A text editor is required for viewing and editing both the main code and driver files (shorter bits of code that interact with and control the main model objects). Ubuntu ships with gedit, which I find works well once you install and activate some useful plugins.
----
$ sudo apt-get install gedit-plugins gedit-developer-plugins
----
Some of these can really increase productivity while writing code.

==== Python

Python is a programming language that is great for analysing and visualising data, and is used here to visualise the output of COVE and running further analyses on model results. Again Python comes preinstalled on Ubuntu, but you could also use it on Windows/Mac. The key package required is https://www.scipy.org/[SciPy] ("scientific python"), which includes NumPy and Matplotlib. These are included with Ubuntu`s preinstalled version of Python. 

It is recommended that you install a Python IDE in order to run plotting functions and perform post-processing. The preferred IDE is https://pythonhosted.org/spyder/[Spyder]. The easiest way to install is from the command line:
----
$ sudo apt-get install spyder
----

==== Mencoder

https://en.wikipedia.org/wiki/MEncoder[Mencoder] is a command line tool that is part of http://www.mplayerhq.hu/design7/news.html[MPlayer] that allows you to encode video files. We use it here to stich together still images of model output in order to create videos of our model coastlines evolving. To install, from the command line, type:
====
$ sudo apt install mencoder
====

=== Windows

Alternatively, if you prefer to continue using Windows, it is possible to get the model working using the http://www.codeblocks.org/home[Code::Blocks] IDE with http://www.mingw.org/[MinGW] (Minimalist GNU for Windows) compilers. The pair are available to install together http://sourceforge.net/projects/codeblocks/files/Binaries/16.01/Windows/[here]. We have not tested COVE extensively in this environment but the <<Examples,examples>> below all compile and run correctly from Code::Blocks.

==== Code::Blocks

Code::Blocks is an IDE with built in compiler and debugger functionality. Head to the http://sourceforge.net/projects/codeblocks/files/Binaries/16.01/Windows/[download page] for Code::Blocks and select the binary executable with the suffix "...mingw_setup.exe". Run through the installation procedure selecting the default options. Once finished, Code::Blocks should load automatically.

==== Python

Python is a programming language that is great for analysing and visualising data, and is used here to visualise the output of COVE and running further analyses on model results. The key package required is https://www.scipy.org/[SciPy] ("scientific python"), which includes NumPy and Matplotlib. If you are using Windows/Mac then we recommend installing a Python distribution such as https://www.continuum.io/why-anaconda[Anaconda].

WARNING: If you have ARCGIS 10.x installed then Python v2.7 will already be installed on your computer. You can either try to build on this installation by adding the packages you need, when you need them (www.lfd.uci.edu/~gohlke/pythonlibs/[This collection] is a good resource for Python Extension binary packages), or work with two versions of Python by installing a second, such as through https://www.continuum.io/why-anaconda[Anaconda].

== Download the model


The COVE code is under continuous development. As we publish scientific papers that use the model, we will provide release versions of the model code associated. The development version is maintained on https://github.com/COVE-Model/COVE[github].

=== Release version

Version 1.0.0 are available as https://github.com/mdhurst1/COVE/archive/1.0.0.tar.gz[tar.gz release version] and https://github.com/mdhurst1/COVE/archive/1.0.0.zip[.zip release version] as used by http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al. (2015)] to explore the sensitivity of crenulate-shaped bays to variation in wave climate. If using this version, once downloaded, extract the contents to an appropriate workspace and you`re ready to continue.

Alternatively, you can clone the release version directly from the repository by running the command:
----
$ git clone https://github.com/COVE-Model/COVE-v1.0.0.git
----

=== Development version

The model is under semi-continuous development (depending on other commitments) and thus the development version is not always going to be functioning and stable. If you wish to work with the latest developments we suggest that you mailto:martin.hurst@glasgow.ac.uk[get in touch] and work with us directly. 

== Getting Started

This chapter provides a brief overview of how to compile and run an example model, and plot the results using Python. For more indepth tutorials, see the later chapters.

=== Linux/UNIX

==== Compiling the code

The code can be compiled in a Linux environment from the command line, using one of the makefiles. These are contained in the `driver_files` subdirectory. The driver files are C++ scripts that control the initiation, running and saving of a COVE model run. In this tutorial we will use the example for running a spiral bay as used in http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al. (2015)].

In a terminal, navigate to the `driver_files` subdirectory:
----
COVE$ cd driver_files
----
Compile COVE for running a spiral bay by launching the makefile:
----
COVE/driver_files$ make -f spiral_bay_make.make
----
This will create an executable `spiral_bay.out` which can be launched from the command line to run the model. First, let`s move the executable to the parent directory, and navigate to the same directory:
----
COVE/driver_files$ mv spiral_bay.out ..
COVE/driver_files$ cd ..
----

==== Running the model

The file spiral_bay.out generated by compiling the code can be launched from the command line:
----
COVE/driver_files$ ./spiral_bay.out
----
Running it in this way will result in it terminating with an error, which will tell you that the program requires a number of input arguments in order to run. In the spiral bay example, the offshore wave climate is represented with three Gaussian distributions, for wave period, height and direction. Each of these is described by a mean and standard deviation, and these are fed to the model as arguments. To run the model with mean wave period of 6 seconds, standard deviation 1 second, mean wave height 1 metre, standard deviation 0.1 metre, and mean wave direction 035^o and standard deviation 25^o:
----
COVE/driver_files$ ./spiral_bay.out 6 1 1. 0.1 35 25
----
The model should then run for fifty years. This example evolves a crenulate-shaped bay from a straight initial coastline between two fixed headlands or sea walls. Sediment is transported out of the model domain by alongshore sediment flux and the shoreline gradually adjusts to the distribution of wave directions. The bay eventually reaches a state of equilibrium where the net alongshore flux is close to zero everywhere. The model is setup to run for 100 years, more than enough time for an equilibrium bay configuration to form.

While running the model will print the current model time to screen, it may also print some other messages, particularly including intersections in the coastline. The intersection analysis detects when the coastline intersects itself, such as when it erodes back behind the headland. Once this has happened the coastline is prevented from eroding any further.

=== Windows

==== Compiling and running: Code::Blocks

Since Code::Blocks is not the current development environment favoured by the COVE team, there is no Code::Blocks project file maintained in the COVE repository, and thus you will need to create one from scratch. Luckily, this process is pretty simple. Having opened Code::Blocks, from the startup click to create a new project: 

image::CB_new.png[]

Select the "Empty project" project template then click through the empty project creation wizard. You will be asked to name the project and provide a file/folder structure (see example) and then to select a compiler (select the GNU GCC Compiler; see example). Keep the default options for "Debug" and "Release" configurations and then click `Finish`.

image::CB_Title.png[]

WARNING: You might have got an error message about the project not being able to save at this point, you can ignore it, the project appears to be saved. If you're not sure about this, right click on the project within the Management side panel, and click `Save project`. 

Next we need to populate the project with the required C++ files. From the top menu, click on `Project -> Add files...` then navigate to the COVE repository directory. Add the following list of files to your project:

----
coastline.cpp, coastline.hpp
cliffline.cpp, cliffline.hpp
waveclimate.cpp, waveclimate.hpp
global_variables.hpp
./driver_files/spiral_bay_driver.cpp <1>
----
<1> Or whichever driver file you wish to work with.

You should be able to expand the project in the Management side-bar to see these files organised by their file type (header or source).

To compile the code, from the top menu, click `Build -> Build`. This will compile and link all of the code automatically and create an executable named `YOUR_PROJECT_NAME.exe` in the `bin` and `debug` folders of your project folder. You can then run the code from Code::Blocks by going to the top menu and clicking `Build -> Run`. If the driver file you have chosen or created requires input arguments, these can be set by clicking `Project -> Set programs' arguments...`.

=== Plotting the results
We make plots of the resulting coastline evolution using the python http://matplotlib.org/[matplotlib] library. To use them you will need a python IDE such as http://pythonhosted.org/spyder/[Spyder]. A series of plotting functions are included in the subdirectory `plotting_functions`. To plot the results of your spiral bay model run, open the file `plot_coastline_evolution_figure.py` in your favourite python IDE, and run. You should get the following figure:

.Example model output for a spiral bay showing the evolution of the bay through time from a starting condition of a straight coastline pinned by two headlands/sea walls. Model evolves to a condition of equilibrium where the coastal morphology changes little through time. 
image::spiral_bay_example.png[width="500",align="center"]

Additionally, below will be a link to a video of a spiral bay evolving, which will be hosted on Vimeo once I have time to work out how to do it (MDH).

== Example model runs
[[Examples]]
In this chapter we will look in detail at how the model is setup to perform a number of different example experiments. First we will look at the evolution of spiral bays from an initially straight coast line bound by sea walls or headlands, as used in http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al. (2015)]. Next we will look at an example of an initially straight coastline using a periodic boundary condition subject to a mixture of low and high angle incidence offshore waves that generate hgih-angle wave instability, similar to the experiments of http://onlinelibrary.wiley.com/doi/10.1029/2005JF000422/abstract[Ashton and Murray, 2006]. Finally we will look at an example setup for a real stretch of cliffed coastline, using a stretch of the Suffolk coastline between Lowestoft and Southwold, which includes the interesting coastal foreland Benacre Ness. Hopefully this will give you some hands on guided experience of how to set the model up and how it behaves under different wave and boundary conditions.

=== Driver files

Each example model run has a driver file. Driver files are the files we will edit in order to control and customise COVE. The driver file initialises the coast, cliffs and waves and runs the coastal simulation following the control parameters that it contains. 

==== Structure of a driver file

[cols="1"]
|===
|Declare Headers
|Manage Input Arguments (if any)
|Declare variables to control model run
|Initialise the coast, cliff and waves using variables
|Set model optional model parameters
|Setup output files
|Run Main Model Loop
|===

==== Structure of the main model loop

The model loop is pretty simple really, first grab a new wave from the wave climate, second pass it to the `Coastline` object when calling the `TransportSediment` function, third print the coordinates of the new `Coastline` to file.

.Structure of the main model loop 
image::main_loop.png[width="600",align="center"]

And in code that looks something like this:

[source,c++]
----
// loop through time and evolve the coast
while (Time < EndTime)
{
  //Get a new wave?
  if (Time > GetWaveTime)
  {
    MyWave = WaveClimate.Get_Wave();
    GetWaveTime += WaveTimeDelta/365.;
  }
 
  //Evolve coast
  CoastVector.TransportSediment(TimeStep, MyWave, CliffVector);
 
  //update time
  Time += TimeStep/365.;
 
  //Write results to file
  if (Time >= PrintTime)
  {
    CoastVector.WriteCoast(WriteCoastFile, Time);
    PrintTime += PrintTimeDelta;
  }
}
----

=== Spiral bays

Let's look at how the model is set up to simulate the formation and evolution of crenulate-shaped bays (also known as spiral, log-spiral, zeta bays). To do so, we will open up the appropriate driver file and work through it to understand how the simulations are set up and what the model is doing.

==== The driver file

The driver file `spiral_bay_driver.cpp` can be found in the `driver_files` subdirectory. You can navigate to it and open in a text editor from the command line with:
----
$ cd driver_files
$ gedit spiral_bay_driver.cpp &
----
or open it from the explorer window.

OK, let's look at the driver file. There are some helpful comments that are ignored when we run the program, these start with "//" or are in blocks "/\*" to "*/". At the top of the file there are some `#include` statements that allow the program access to some libraries we will be using, including the model`s main coastline and waveclimate objects.

==== Setting up the wave climate

The spiral_bay_driver uses a Guassian representation of the wave climate. The parameters to set up the wave climate are required as input arguments at runtime. The wave climate is defined by a _mean_ and _standard deviation_ value for:

* Wave period latexmath:[T]
* Wave height latexmath:[H_0]
* Wave direction latexmath:[\theta_0]

and hence 6 input arguments are required. The driver file runs a check at the start to make sure it has the correct number of arguments, and will terminate with an error message if not.

In order to initialise the wave climate the 6 input arguments first are assigned to 6 variables:

[source,c++]
----
//Declare parameter for wave conditions
double OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveDirection, OffshoreStDWaveDirection, OffshoreMeanWaveHeight, OffshoreStDWaveHeight;
----

and the corresponding input arguments are converted from character sequences to numerical values and passed to these variables.

The wave climate is initialised by declaring a `GuassianWaveClimate` object called `WaveClimate` and passing these variables as input arguments in the correct order.

[source,c++]
----
// initialise the wave climate
GaussianWaveClimate WaveClimate = GaussianWaveClimate(OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveDirection, OffshoreStDWaveDirection, OffshoreMeanWaveHeight, OffshoreStDWaveHeight);
----

We then also declare an individual wave object. This holds the period, height and direction of an individual wave `MyWave` which we later pass to the coastline object in order to drive coastal evolution. We will sample a wave from `WaveClimate` and pass it to `MyWave`

[source,c++]
----
// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from thewave climate object
MyWave = WaveClimate.Get_Wave();
----

==== Model run control parameters

Various parameters are required to control the length of the model run (in years), how often the coastline position is output to file (in years), how often to sample a new wave from the wave climate object (days), and how big the model timestep should be (days). We suggest leaving these as they are for now, but as you start customising model setup you may need to adjust them.

[source,c++]
----
//declare time control paramters
int EndTime = 50.; // End time (years)
double Time = 0.; // Start Time (years)
double PrintTimeDelta = 36.5/365.; // how often to print coastline (years)
double PrintTime = PrintTimeDelta; // Print time (years)

double WaveTimeDelta = 0.1; // Frequency at which to sample new waves (days)
double GetWaveTime = 0.0; // Time to get a new wave (days)
double TimeStep = 0.05; // Time step (days)
----

==== Initialise the model

The spiral bay model is initialised as a straight coast with fixed boundaries at each end of the coast line. In order to generate the coastline object, we need to prescribe some attributes that dictate the properties of the generated coast, which we will pass to the new Coastline object when we declare it.

[source,c++]
----
//initialise coast as straight line with low amp noise
int MeanNodeSpacing = 50; // in metres
double CoastLength = 2000; // in metres
double Trend = 140.; // in degrees
	
//boundary conditions are fixed
int StartBoundary = 2;
int EndBoundary = 2;		
----

* `MeanNodeSpacing` sets approximately how widely spaced the Coastline cells will be. It is a mean value, because as the model evolves, nodes might get closer together or further apart, and nodes will be dynamically added or destroyed accordingly in order to maintain this average. 
* `CoastLength` is the length of the coastline between the fixed (or otherwise) end nodes.
* `Trend` is the orientation (azimuth) that the straight coastline should extend in.

NOTE: The sea is always on the left side of the vector, so imagine you are standing at node '[0]' looking down the vector. If the `Trend` is 140^o^ then the sea is to the nort-east and the land to the south-west.

OK now that we have these variables in place we can go ahead and declare the Coastline object.

[source,c++]
----
//initialise the coastline as a straight line
Coastline CoastVector = Coastline(MeanNodeSpacing, CoastLength, Trend, StartBoundary, 
	EndBoundary);
	
//Initialise an empty/dummy cliffline object here
Cliffline CliffVector;
----

We declare a `Coastline` object whech we have called `CoastVector`, this is our coast, and all of its morphological properties are stored internally within the object. We provide the input arguments to the call in the order listed. 

Note there is also a call to declare a `Cliffline` object called `CliffVector`. It has no input arguments and therefore generates an empty `Cliffline` object (i.e. there is no actual cliff line inside it). Our spiral bay experiments don`t require a cliffline object so that is OK, but this declaration is required to keep the model happy (it needs to be able to look at a cliff to know it doesn`t really exist, it`s a dummy cliff). Don`t worry about this for now, this will generate a warning when we come to run the model but we are OK to ignore it.

Finally, for our spiral bay runs, we want to allow some simple rules for the refreaction and diffraction of waves behind coastal obstructions to be operating. To do this we need to set a flag within the `Coastline` object, 1 = on, 0 = off. 

[source,c++]
----
// Allow refraction/diffraction rules
int RefDiffFlag = 1;
CoastVector.SetRefDiffFlag(RefDiffFlag);
----

Finally, before we run the main model loop, we'll write the initial conditions to file:

[source,c++]
----
// loop through time and evolve the coast
CoastVector.WriteCoast(WriteCoastFile, Time);
----

==== Main model loop

We're all set up and ready to go! The model loop is pretty simple really, first grab a new wave from the wave climate, second pass it to the `Coastline` object when calling the `TransportSediment` function, third print the coordinates of the `Coastline` to file. 

The model evolves until the `Time` exceeds the prescribed `EndTime`:

[source,c++]
----
while (Time < EndTime)
{
	...	
----

We grab a new wave from the wave climate if it's time (`GetWaveTime` depends on `WaveTimeDelta` which sets how often we get a new wave):

[source,c++]
----
//Get a new wave?
if (Time > GetWaveTime) 
{
	MyWave = WaveClimate.Get_Wave();
	GetWaveTime += WaveTimeDelta/365.;
}
----

Notice that `GetWaveTime` is in years, but `WaveTimeDelta` is in days, so we divide through by 365 to convert.

Now we evolve the coast by calling the `Coastline` function `TransportSediment`. This requires three input arguments, `TimeStep` is the length of time that sediment is transported over, we also give it the wave `MyWave`, and finally the dummy Cliffline object `CliffVector`:

[source,c++]
----
//Evolve coast
CoastVector.TransportSediment(TimeStep, MyWave, CliffVector);
----

A whole lot of things happen inside this function (see a later section of this documentation that is yet to be written). The shoreline geometry is recalculated at each timestep. The wave is transformed from offshore to wave breaking conditions following linear wave theory, and any wave shadowing and refraction/diffraction are calculated. Alongshore sediment transport for each cell is calculated and the change in the volume of sediment in each cell calculated from the divergence of alongshore flux. The volume change is inverted for a change in the position of the coast and the position of each node is updated accordingly. The coastal geometry is updated for the next timestep.

There is a crude attempt written in here to allow adaptive timestepping. This hasn't fully been tested yet, and usually if it's called it's because there is a bug in the model not actually associated with the adaptive timestep. If you run into this problem please mailto:martin.hurst@glasgow.ac.uk[email me].

Finally, the model prints the updated _X_ and _Y_ coordinates to an output file. See Writing Results to File for details of the resulting file format.

==== Compile and Run

Compile COVE for running a spiral bay by launching the makefile:

----
COVE/driver_files$ make -f spiral_bay_make.make
----

The file spiral_bay.out generated by compiling the code can be launched from the command line. The program takes the wave climate parameters as inputs latexmath:[T_{mean}],latexmath:[T_{std}],latexmath:[H_{mean}],latexmath:[H_{std}],latexmath:[\theta_{mean}],latexmath:[\theta_{std}]:

----
COVE/driver_files$ ./spiral_bay.out 6 1 1. 0.1 35 25
----

The model should then run for fifty years. This example evolves a crenulate-shaped bay from a straight initial coastline between two fixed headlands or sea walls. Sediment is transported out of the model domain by alongshore sediment flux and the shoreline gradually adjusts to the distribution of wave directions. The bay eventually reaches a state of equilibrium where the net alongshore flux is close to zero everywhere. The model is setup to run for fifty years, more than enough time for an equilibrium bay configuration to form.

While running the model will print the current model time to screen, it may also print some other messages, particularly including intersections in the coastline. The intersection analysis detects when the coastline intersects itself, such as when it erodes back behind the headland. Once this has happened the coastline is prevented from eroding any further.

==== Plotting the results

A series of plotting functions are included in the subdirectory `plotting_functions`. To plot the results of your spiral bay model run, open the file `plot_coastline_evolution_figure.py` in your favourite python IDE, and run. You should get the following figure:

.Example model output for a spiral bay showing the evolution of the bay through time from a starting condition of a straight coastline pinned by two headlands/sea walls. Model evolves to a condition of equilibrium where the coastal morphology changes little through time. 
image::spiral_bay_example.png[width="500",align="center"]

=== Cusps, Capes and Spits

In this example, we will setup a model that simulates the formation of cusps, capes and spits, similar to the experiments of Ashton and Murray (2006). The type of coastal landform that the model produces depends on the nature of the wave climate used. Ashton and Murray (2006) developed a 4-bin approach to characterising offshore wave climates using two paramters; the proportion of waves that approach from high angle (_U_) and the proportion of waves that approach from the "left" (_A_), that is to say, the proportion of waves that would drive alongshore sediment transport _down_ coast on a straight coastline (see section X for more info on this wave climate).

==== The driver file

The appropriate driver file is `straight_periodic_driver.cpp` and can be found in the `driver_files` subdirectory. You can navigate to it and open in a text editor from the command line with:
----
$ cd driver_files
£ gedit straight_periodic_driver.cpp &
----
or open it from the explorer window.

The driver file has been commented up helpfully to explain what is going on throughout. The driver file structure follows that laid out in section 5.1 (add link). We will assume you are already familiar with the `spiral_bay_driver.cpp` example.

==== Setting up the wave climate

Out straight, periodic boundary model run uses a UA wave climate, and hence 2 input arguments are required:
*Wave direction highness (_U_)
*Wave direction asymmetry (_A_)

Other wave parameters (period and height) are assigned explicitly within the driver file.

=== Real cliffed coast

Let's look at how to set the model up to run on a real stretch of cliffed coastline. The example we are going to look at is from the coast of Suffolk between Lowestoft and Southwold (see Figure 5).

Insert figure here of study site.

This coastline experiences a bimodal wave climate, with waves coming out of the North Sea to the north east, and through the English Channel from the South.

We are interested in this stretch of coastline because at Kessingland there is a large coastal foreland called Benacre Ness that is migrating northward along the coast. It is called Benacre Ness because it used to sit in front of the Benacre estate, but has migrated northward and now stretches across the frontage of Kessingland. It has been estimated to extend northward at rates of 20-50 m y^-1^, despite the locally established view that alongshore sediment transport is directed from north to south.

==== The driver file

The driver file `benacre_driver.cpp` can be found in the `driver_files` subdirectory. Hopefully the comments in the code will be helpful as you look through. These are ignored when the program is run. At the top of the file there are some `#include` statements that allow the program access to some libraries we will be using, including the model`s main coastline, cliffline and waveclimate objects.

==== Model run control parameters

Various parameters are required to control the length of the model run (in years), how often the coastline and cliffline positions are output to file (in years), how often to sample a new wave from the wave climate object (days), and how big the model timestep should be (days). We suggest leaving these as they are for now, but as you start customising model setup you may need to adjust them.

[source,c++]
----
	//declare time control paramters
	int EndTime = 50.;	// End time (years)
	double Time = 0.;	// Start Time (years)
	double PrintTimeDelta = 36.5/365.;	// how often to print coastline (years)
	double PrintTime = PrintTimeDelta;	// Print time (years)
		
	double WaveTimeDelta = 0.2;	// Frequency at which to sample new waves (days)
	double GetWaveTime = 0.;	// Time to get a new wave (days)
	double TimeStep = 0.2;	// Time step (days)
	double MaxTimeStep = 0.2;	// Maximum timestep (days)	
----

==== Input files

Using a real coastline, the model will require three input files in order to initialise the coast. A coastline _x-y_ file, a cliffline _x-y_ file and cliff type file. These are available in the `example_inputs` subdirectory of the repository. From the `driver_file` directory copy these across at the command line ready for running the model:

----
/COVE/driver_files/$ cp ../example_inputs/* .
----

These files have been declared in the driver file:

[source,c++]
----
// initialise the coastline and cliffline objects from file
// first declare the filenames
string CliffInFile = "Benacre_Cliffline_Points.xy";
string CoastInFile = "Benacre_Coastline_Points.xy";
string FixedFileName = "Benacre_Fixed_Cliffs.data";
----

The coastline and cliffline _*.xy_ files have the same format as the model output, consisting of a header line with two space-separated integers representing the start and end boundary conditions, followed by lines containing the _x_ and _y_ coordinates of the coastline, preceded by the time (see "Read a coast from file" in the "under the hood" section). 

----
StartBoundary | EndBoundary
Time | X[0] | X[1] | X[2] =====> X[NoNodes]
Time | Y[0] | Y[1] | Y[2] =====> Y[NoNodes]
----

The order that your _x_ and _y_ coordinates come in is very important. The model *ALWAYS* assumes that the sea is on the left side as it works its way down the coastline or cliffline vector. To be sure you get this correct, imagine you are standing at the first node on your coastline, looking towards the second node. The sea will be on the left of the line, and the land on the right (see Figure 5). If this is backwards, you will get some very strange behaviour, because the model will ignore alot of waves (since they are coming from the land) and beach widths will be negative. If your first attempt at modelling a stretch of coastline blows up straight away, this is the first thing to check. We should probably write some error checking into the beach width calculator to flag negative values and warn you. This will get added in later.

.Google Earth image of the coastline of Suffolk between Lowestoft and Southwold showing the beginning and end of the coastline vector the correct way around. 
image::coastline_orientation.png[width="500",align="center"]

The third file required is a cliff type file. This tells the model whether a cliff node can erode or is fixed (this can later be expanded to include different types of geology). Currently a value of 1 represents a fixed coast (e.g. defended by sea wall/revetment) and a value of 0 is a normal erodible cliff. The file format is a header line followed by two columns, one for the node index (`i=0` to `i=NoNodes-1`) and the second for the cliff type integer.
----
Index Type
0 1
1 0
2 0
...
NoNode-1 1
----

==== Wave climate

Wave data from the Southwold wave buoy shows that our example coast is hit by a bimodal wave climate. The wave buoy is in 25 m water depth and suggests high angle waves impinging toward the coast, which if fed directly to the model results in high angle wave instability that is not observed on this stretch of coastline. A legacy data set from a previously deployed AWAC wave buoy shows that these dominant wave modes get rotated to lower angle of incidence by the time they reach the shoreface, so for these example experiments, we have chosen a similar lower angle, bimodal wave climate.

Our bimodal wave climate consists of two Gaussian wave climates as used in the spiral bay experiments. The parameters for these have been declared in the driver file diectly rather than being passed as input arguments.

[source,c++]
----
// Bimodal wave climate
//Wave climate 1
double OffshoreMeanWaveDirection1 = 45.;
double OffshoreStDWaveDirection1 = 20.;
double OffshoreMeanWavePeriod1 = 6.;
double OffshoreStDWavePeriod1 = 2.;
double OffshoreMeanWaveHeight1 = 0.8;
double OffshoreStDWaveHeight1 = 0.2;
GaussianWaveClimate WaveClimate1(OffshoreMeanWavePeriod1,OffshoreStDWavePeriod1,OffshoreMeanWaveDirection1,OffshoreStDWaveDirection1,OffshoreMeanWaveHeight1, OffshoreStDWaveHeight1);

//Wave climate 2
double OffshoreMeanWaveDirection2 = 140.;
double OffshoreStDWaveDirection2 = 20.;
double OffshoreMeanWavePeriod2 = 5.;
double OffshoreStDWavePeriod2 = 1.;
double OffshoreMeanWaveHeight2 = 1.1;
double OffshoreStDWaveHeight2 = 0.2;
GaussianWaveClimate WaveClimate2(OffshoreMeanWavePeriod2,OffshoreStDWavePeriod2,OffshoreMeanWaveDirection2,OffshoreStDWaveDirection2,OffshoreMeanWaveHeight2, OffshoreStDWaveHeight2);
----

So we have two wave climate objects, `WaveClimate1` and `WaveClimate2`. As before we also need to declare an individual wave object:

[source,c++]
----
//declare wave	
Wave MyWave = Wave();
MyWave = WaveClimate1.Get_Wave();
----

In the main model loop, we will use a random number generate to select which wave climate to grab a wave from at random, and assign it to `MyWave` ready to evolve the coast.

==== Initialisation

We initialise both the coastline and the cliffline objects by pointing them to the respective input files as detailed in the previous subsection. We then provide an extra call to the CliffVector object to tell it to read whether the cliff is fixed or erodible:

[source,c++]
----
// Read the coastline and cliffline data from files
double StartTime = 0;
Cliffline CliffVector = Cliffline(CliffInFile, StartTime);
Coastline CoastVector = Coastline(CoastInFile, StartTime);

// Load data on cliff type (fixed vs erodible)
CliffVector.ReadCliffType(FixedFileName);
----

Then we declare a couple more file names where we will write the output files for both the cliffline and the coastline object:

[source,c++]
----
//declare output file names
string WriteCoastFile = "CliffedCoast_Coastline.xy";
string WriteCliffFile = "CliffedCoast_Cliffline.xy";
----

There are a few other things we need to set up for this run; how fast the cliffs can erode, how high the cliffs are, what the critical beach width is that maximises cliff erosion, and how much cliff material gets lost offshore when the cliff erodes.

First, we will setup the maximum retreat rate. This is the fastest retreat rate the cliffs can manage, and can be informed or calibrated by historical observations of cliff retreat. For our section of the Suffolk coast, we will set this to 5 m yr^-1^, guided by http://www.sciencedirect.com/science/article/pii/S0169555X10003533[Brooks and Spencer (2010)].

[source,c++]
----
// Set Maximum Retreat Rate (m/yr)
// This is E0 for the Valvo et al. (2006) or Limber and Murray (2011) models of cliff erosion
double RetreatRate = 5.;
CliffVector.SetMaxRetreatRate(RetreatRate);
----

Second, we will set the cliff height. At the moment this is spatially and temporally continuous, but functionality can be added later to extract this value from a DEM as the model evolves.

[source,c++]
----
// Set Cliff Height (m)
// Fixed for now, but could in the future grab this from a DEM
double CliffHeight = 10.;
CliffVector.SetCliffHeight(CliffHeight);
----

Third, we set the critical beach width. This is the beach width at which the maximum rate of cliff retreat occurs. For wider beaches, the rate of cliff retreat declines exponentially. We will set this to 5 m, suggesting that a 5 m wide beac provides the optimal balance between protecting the cliff and providing abrasive tools such that cliff erosion is maximised.

[source,c++]
----
// Set critical beach width (m)
// The beach width that maximises the rate of cliff retreat E0
double CriticalBeachWidth = 5.;
CliffVector.SetCriticalWidth(CriticalBeachWidth);
----

Fourth, we set the style of cliff retreat. `ErosionType = 1` if using a http://onlinelibrary.wiley.com/doi/10.1029/2005JF000340/full[Valvo et al. (2006)] type of relationship between beach width and cliff retreat (this is effectively the same as setting `CriticalBeachWidth = 0` and thus redundant). 'ErosionType = 2' uses the http://geology.gsapubs.org/content/39/12/1147.short[Limber and Murray (2011)] relationship between beach width and cliff retreat where cliff retreat rate peaks at `CriticalBeachWidth`.

[source,c++]
----
// For Valvo Style Cliff Retreat ErosionType = 1, 
// for Limber and Murray ErosionType = 2
int ErosionType = 1;
----

Fifth, we set the proportion of cliff material assumed to be lost to the sea:

[source,c++]
----
// Set lost cliff fraction
// The proportion of cliff material that is lost offshore by suspension
double LostFraction = 0.2;
CliffVector.SetLostFraction(LostFraction);
----

And finally, since the Suffolk beaches are mixed sand/shingle, we tell the coastline object to use an alongshore flux equation that has been modified to better reflect gravel transport rates:

[source,c++]
----
// Set lost cliff fraction
// The proportion of cliff material that is lost offshore by suspension
double LostFraction = 0.2;
CliffVector.SetLostFraction(LostFraction);
----

==== Main model loop

Good to go! The model loop is pretty simple really, first grab a new wave at random from one of the two wave climates, second pass it to the `Coastline` object when calling the `TransportSediment` function, third call the `Cliffline` object's `ErodeCliff` function, and finally print the coordinates of both the `Coastline` and `Cliffline` to file. 

The model evolves until the `Time` exceeds the prescribed `EndTime`:

[source,c++]
----
while (Time < EndTime)
{
	...	
----

We grab a new wave from the wave climate if it's time (`GetWaveTime` depends on `WaveTimeDelta` which sets how often we get a new wave):

[source,c++]
----
//Get a new wave?
if (Time > GetWaveTime) 
{
	// Use a random sampler to chose between wave climates
	rand1 = (double)rand()/RAND_MAX;
	if (rand1 < 0.5) MyWave = WaveClimate1.Get_Wave();
	else MyWave = WaveClimate2.Get_Wave();
	GetWaveTime += WaveTimeDelta/365.;
}
----

`rand1` selects a random number between 0 and 1. When `rand1 < 0.5` we use `WaveClimate1` and otherwise we use `WaveClimate2` so we should be sampling equally from both wave climates. Notice that `GetWaveTime` is in years, but `WaveTimeDelta` is in days, so we divide through by 365 to convert.

Now we evolve the coast by calling the `Coastline` function `TransportSediment`, followed by the `Cliffline` function `ErodeCliff`. Each requires three input arguments. For the `Coastline.TransportSediment` call, `TimeStep` is the length of time that sediment is transported over, we also give it the wave `MyWave`, and finally the `Cliffline` object `CliffVector` so that it can only erode beach material that fronts the cliff. For the `Cliffline.ErodeCliff` call, we pass `TimeStep` again, the `Coastline` object, and the type of erosion law `ErosionType`.

[source,c++]
----
//Evolve coast
CoastVector.TransportSediment(TimeStep, MyWave, CliffVector);
CliffVector.ErodeCliff(TimeStep, CoastVector, ErosionType);
----

A whole lot of things happen inside these functions (see a later section of this documentation that is yet to be written). Coastline and Cliffline geometry is recalculated at each timestep. The wave is transformed from offshore to wave breaking conditions following linear wave theory, and any wave shadowing and refraction/diffraction are calculated. Alongshore sediment transport for each cell is calculated and the change in the volume of sediment in each cell calculated from the divergence of alongshore flux, checking with the Cliffline position that sediment is available for transport. The volume change is inverted for a change in the position of the coast and the position of each node is updated accordingly. The coastal geometry is updated for the next timestep. The width of the beach is calculated by comparing the Coastline and Cliffline objects and this determines the amount of cliff retreat. The Cliffline position is updated and the amount of volume lost is supplied to the adjacent beach, minus the amount lost to the sea.

Finally, the model prints the updated _X_ and _Y_ coordinates to two output files. See Writing Results to File for details of the resulting file format.

==== Compile and run

Compile COVE for running the Suffolk example by launching the makefile:

----
COVE/driver_files$ make -f benacre_make.make
----

The file benacre.out generated by compiling the code can be launched from the command line without any input arguments :

----
COVE/driver_files$ ./benacre.out
----

The model should then run for fifty years. This example evolves the Suffolk coast such that the cuspate foreland Benacre Ness migrates northward up the coast at rates in keeping with historical observations. While running the model will print the current model time to screen.

==== Plotting the results

A series of plotting functions are included in the subdirectory `plotting_functions`. To plot the results of your Suffolk model run, open the file `benacre_evolution_animation.py` in your favourite python IDE, and run. You should get a series of figures whose file names are numbered sequentially and each looks a bit like this:

.Example model output from the Suffolk coast showing the stretch of coastline between Lowestoft and Southwold. 
image::benacre_output.png[width="300",align="center"]

The python script creates a file called filelist.txt which contains a list of all the output filenames. These frames can then be stitched together to create a video of the coastline evolving using https://en.wikipedia.org/wiki/MEncoder[Mencoder], a command line tool that is part of http://www.mplayerhq.hu/design7/news.html[MPlayer] that allows you to encode video files. Thus once you have run the python script, you can run the following command to stich the output together into a nice video:

----
$ mencoder mf://@filelist.txt -mf w=300:h=600:fps=25:type=png -ovc lavc -lavcopts vcodec=mpeg4:mbd=2:trell -oac copy -o video.avi
----

Once you've made the video, you can delete all the individual png frame files to keep things tidy:
----
$ rm *.png
----

== Wave Climates

The model requires wave conditions to drive alongshore sediment transport. This is supplied in the form of a waveclimate object that the coastline model can interact with. For the purposes of this model, a wave climate consists of a timeseries of waves considered to be "offshore", that is to say the wave conditions recieved at the bottom of the shoreface. This time series comprises significant wave height latexmath:[H_0], wave period latexmath:[T] and wave direction latexmath:[\theta_0]. The waveclimate object can take a variety of guises, including both hypothetical and real wave climates. the model is most sensitive to variation in _wave direction_. Hypothetical wave climates include the U-A descripition of wave directions (Ashton & Murray, 2006) or a simple Gaussian distribution (Hurst et al., 2015). Real wave climates read in a timeseries of latexmath:[H_0], latexmath:[T] and latexmath:[\theta_0] data that might be collected from a nearby wave buoy deployment, or generated by a coastal area model such as http://fvcom.smast.umassd.edu/fvcom/[FVCOM] or http://www.swan.tudelft.nl/[SWAN].

=== Single wave

=== Gaussian wave climate

The `GuassianWaveClimate` object contains six parameters to describe distributions of Wave period latexmath:[T], Wave height latexmath:[H_0], and Wave direction latexmath:[\theta_0]. In order to initialise the wave climate in a driver file, 6 variables must be declared, and values assigned:

[source,c++]
----
//Declare parameter for wave conditions
double OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveDirection, 
	OffshoreStDWaveDirection, OffshoreMeanWaveHeight, OffshoreStDWaveHeight;
----

The wave climate is initialised by declaring a `GuassianWaveClimate` object called `WaveClimate` and passing these variables as input arguments in the correct order.

[source,c++]
----
// initialise the wave climate
GaussianWaveClimate WaveClimate = GaussianWaveClimate(OffshoreMeanWavePeriod,
	OffshoreStDWavePeriod, OffshoreMeanWaveDirection, OffshoreStDWaveDirection,
	OffshoreMeanWaveHeight, OffshoreStDWaveHeight);
----

We then also declare an individual wave object. This holds the period, height and direction of an individual wave `MyWave` which we later pass to the coastline object in order to drive coastal evolution. We will sample a wave from `WaveClimate` and pass it to `MyWave`

[source,c++]
----
// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();
----

This last line should appear in the main model loop to select new waves at the chosen frequency:

[source,c++]
----
while (Time < EndTime)
{
	//Get a new wave?
	if (Time > GetWaveTime) 
	{
		MyWave = WaveClimate.Get_Wave();
		GetWaveTime += WaveTimeDelta/365.;
	}
	...
----

=== Bimodal  wave climate

A bimodal wave climate can be created by using two other wave climate objects such as the Gaussian wave climate, and sampling between the two at random. To set up such a model, first declare two Gaussian wave climates with the chosen parameters:

[source,c++]
----
// Bimodal wave climate
//Wave climate 1
double OffshoreMeanWaveDirection1 = 45.;
double OffshoreStDWaveDirection1 = 20.;
double OffshoreMeanWavePeriod1 = 6.;
double OffshoreStDWavePeriod1 = 2.;
double OffshoreMeanWaveHeight1 = 0.8;
double OffshoreStDWaveHeight1 = 0.2;
GaussianWaveClimate WaveClimate1(OffshoreMeanWavePeriod1,OffshoreStDWavePeriod1,OffshoreMeanWaveDirection1,OffshoreStDWaveDirection1,OffshoreMeanWaveHeight1, OffshoreStDWaveHeight1);

//Wave climate 2
double OffshoreMeanWaveDirection2 = 140.;
double OffshoreStDWaveDirection2 = 20.;
double OffshoreMeanWavePeriod2 = 5.;
double OffshoreStDWavePeriod2 = 1.;
double OffshoreMeanWaveHeight2 = 1.1;
double OffshoreStDWaveHeight2 = 0.2;
GaussianWaveClimate WaveClimate2(OffshoreMeanWavePeriod2,OffshoreStDWavePeriod2,OffshoreMeanWaveDirection2,OffshoreStDWaveDirection2,OffshoreMeanWaveHeight2, OffshoreStDWaveHeight2);
----

Then declare an individual wave object:
[source,c++]
----
// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();
----

In the main model loop we will use a random number generator to choose which of the two wave climates to select from. The fraction `0.5` dictates that we should sample roughly half of the waves from each wave climate. This could be adjusted if it was required that one mode should be more dominant.

[source,c++]
----
while (Time < EndTime)
{
	//Get a new wave?
	if (Time > GetWaveTime) 
	{
		// Use a random sampler to chose between wave climates
		rand1 = (double)rand()/RAND_MAX;
		if (rand1 < 0.5) MyWave = WaveClimate1.Get_Wave();
		else MyWave = WaveClimate2.Get_Wave();
		GetWaveTime += WaveTimeDelta/365.;
	}
	...
----

=== U-A wave climate

=== Real wave data

The model can be driven by wave data such as that taken from a wave buoy or supplied from an external wave model such as http://fvcom.smast.umassd.edu/fvcom/[FVCOM] or http://www.swan.tudelft.nl/[SWAN]. The required input parameters are offshore wave direction, period and height.

Input files should have a header line, and three data columns for direction, period and height.

----
Headers
   Dir[0]    |    Period[0]    |    Height[0]
   Dir[1]    |    Period[1]    |    Height[1]	
   Dir[2]    |    Period[2]    |    Height[2]	
    ...      |       ...       |      ...		
Dir[NoWaves] | Period[NoWaves] | Height[NoWaves]
----

The model doesn't read how frequent the data are, but the frequency with which the model samples this data can be set in a driver file. The data is read and sampled in the order provided.

The wave climate is initialised in a driver file by passing the input filename as a `string`:

[source,c++]
----
// initialise the wave climate
WaveFileName = "MyWaveData.txt";
RealWaveClimate WaveClimate = RealWaveClimate(WaveFileName);
----

An individual wave object will also be required:

[source,c++]
----
// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
----

A wave is then sampled from the wave climate by assigning it the individual wave object:
[source,c++]
----
// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();
----

Note that the model will proceed iteratively through the wave climate data until it reaches the end of the file, then will loop back to the beginning and keep going continously until the model run is ended.

== Under the hood

=== Initialising a Coastline object

==== Read a Coastline from file

Input files for the position of the coast take the same format as output files. The first line is a header containing integer values for the `StartBoundary` and `EndBoundary` conditions. The next two lines are the X and Y coordinates of the line respectively, but both preceded by the time (in years). We use \| to indicate a white space delimiter here such as a space or tab.
----
StartBoundary | EndBoundary
Time | X[0] | X[1] | X[2] =====> X[NoNodes]
Time | Y[0] | Y[1] | Y[2] =====> Y[NoNodes]
----
So for example, a 5 metre long coastline with fixed boundary conditions oriented at 135^o with a latexmath:[sqrt{2}] node spacing, at `Time = 0` would have an input file:
----
2 2
0 0 1 2 3 4 5
0 0 1 2 3 4 5
----

=== Initialising a Cliffline object

=== Boundary Conditions

The model is a single line. The start and end of the line can be handled in different ways. At the moment, we have two possible boundary conditions, which are assigned by setting the `StartBoundary` and `EndBoundary` parameters when initialising the coastline, or putting these in the header of an input file if initialising the coastline with an existing coastline output file (or real coastline). The boundary conditions are set by an integer as:
1. Periodic boundary conditions: the start of the line is also the end, and sediment can be passed \"round the back\" e.g. an island.
2. Fixed boundary conditions the first and last two nodes/cells in the model are fixed and immovable.


=== Writing results to file

The `Coastline` object writes the position of the coast to a text file with a name provided in the call `WriteCoastFile`. The `Time` must also be passed:

[source,c++]
----
//loop through time and evolve the coast
CoastVector.WriteCoast(WriteCoastFile, Time);
----

The file format is the same as for reading a coast from a text file. The first line is a header containing integer values for the `StartBoundary` and `EndBoundary` conditions. The next two lines are the X and Y coordinates of the line respectively, but both preceded by the time (in years). We use \| to indicate a white space delimiter here such as a space or tab.
----
StartBoundary | EndBoundary
Time | X[0] | X[1] | X[2] =====> X[NoNodes]
Time | Y[0] | Y[1] | Y[2] =====> Y[NoNodes]
----
So for example, a 5 metre long coastline with fixed boundary conditions oriented at 135^o with a latexmath:[sqrt{2}] node spacing, at `Time = 1`, that has not changed since `Time = 0` would have an input file:
----
2 2
0 0 1 2 3 4 5
0 0 1 2 3 4 5
1 0 1 2 3 4 5
1 0 1 2 3 4 5
----

More details to follow. See the [Doxygen documentation] for the time being.

== Ensemble mode

Details to follow.

== References

[small]#Ashton, A. D., and A. B. Murray (2006), High-angle wave instability and emergent shoreline shapes: 1. Modeling of sand waves, flying spits, and capes, _J. Geophys. Res._,
111, F04011, doi: http://dx.doi.org/10.1029/2005JF000422[10.1029/2005JF000422].#

[small]#Barkwith, A., Thomas, C. W., Limber, P. W., Ellis, M. A., and Murray, A. B. (2014a), Coastal vulnerability of a pinned, soft-cliff coastline – Part I: Assessing the natural sensitivity to wave climate, _Earth Surf. Dynam._, 2, 295-308, doi: http://dx.doi.org/10.5194/esurf-2-295-2014[10.5194/esurf-2-295-2014].#

[small]#Barkwith, A., Hurst, M. D., Thomas, C. W., Ellis, M. A., Limber, P. L., and Murray, A. B. (2014b) Coastal vulnerability of a pinned, soft-cliff coastline, II: assessing the influence of sea walls on future morphology, _Earth Surf. Dynam._, 2, 233-242, doi: http://dx.doi.org/10.5194/esurf-2-233-2014[10.5194/esurf-2-233-2014].#

[small]#Brooks, S. M., and T. Spencer (2010), Temporal and spatial variations in recession rates and sediment release from soft rock cliffs, Suffolk coast, UK, _Geomorph._, 124, 26-41, doi: http://dx.doi.org/10.1016/j.geomorph.2010.08.005[10.1016/j.geomorph.2010.08.005].#

[small]#Hurst, M. D., A. Barkwith, M. A. Ellis, C. W. Thomas, and A. B. Murray (2015), Exploring the sensitivities of crenulate bay shorelines to wave climates using a new vector-based one-line model, _J. Geophys. Res. Earth Surf._, 120, 2586–2608, doi: http://dx.doi.org/10.1002/2015JF003704[10.1002/2015JF003704].#

[small]#Limber, P. W. and A. Brad Murray (2011) Beach and sea-cliff dynamics as a driver of long-term rocky coastline evolution and stability, _Geology_, 39, 1147-1150, doi: http://dx.doi.org/10.1130/G32315.1[10.1130/G32315.1]#

[small]#Valvo, L. M., A. B. Murray, and A. Ashton (2006), How does underlying geology affect coastline change? An initial modeling investigation, _J. Geophys. Res._, 111, F02025, doi: http://dx.doi.org/10.1029/2005JF000340[10.1029/2005JF000340]#


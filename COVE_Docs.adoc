= COVE: Coastal Vector Evolution Model
Martin D. Hurst, Andrew Barkwith, Christopher W. Thomas, Michael A. Ellis, A. Brad Murray
:toc: left
:stem: latexmath
:imagesdir: ./images/
:numbered:
:source-highlighter: coderay

image::COVE_logo.png[width="100", height="100"]

== Introduction

This is the documentation for COVE, the COastal Vector Evolution model - a vector-based one-line coastal evolution model. The model was presented and used in a http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[paper] on the evolution of crenulate bays published in the _Journal of Geophysical Research Earth Surface_ (http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al., 2015]). The model is intended for research purposes, exploring coastal behaviour and sensitiviy. If you are interested in working with COVE, we would encourage you to mailto:martin.hurst@glasgow.ac.uk[get in touch] and work with us. In this introduction, we will give a brief overview of the science behind the model.

Reference documentation for the code has been generated using Doxygen and the resulting reference material can be accessed at https://COVE-model.github.io/COVE/documentation/html/index.html[COVE Doxygen Documentation].

*SUMMARY*
====
- COVE is a ‘one-line’ type shoreline evolution model.
- Application at spatial scales of kms to tens of kms, over decadal to millennial timescales.
- Coastal change is driven by gradients in wave-generated alongshore sediment transport.
- Alongshore sediment transport driven by the height and angle of breaking waves.
- Retreat of cliffs governed by beach interaction (protection vs tools).
====

=== Overview

The COVE model is a special case of a ‘one-line’ model designed to handle complex coastline geometries, with high planform curvature shorelines (http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al., 2015]). The shoreline is represented by a single line (or contour) that advances or retreats depending on the net alongshore sediment flux. COVE is now actually a two-line model because a second line representing coastal cliffs interacts with the shoreline, eroding to provide beach sediment. One-line models make a number of simplifying assumptions to conceptualise the coastline allowing the ‘one-line’ representation of the coastline:

*ASSUMPTIONS*
====
1. Short-term cross-shore variations due to storms or rip currents are considered temporary perturbations to the long-term
trajectory of coastal change (i.e. the shoreface recovers rapidly from storm-driven cross-shore transport).
2. The beach profile is thus assumed to maintain a constant time-averaged form (Fig. 1), implying that depth contours are
shore-parallel and therefore allows the coast to be represented by a single contour line.
3. Alongshore sediment transport occurs primarily in the surf zone, and cross-shore sediment transport acts to maintain the
equilibrium shoreface as it advances /retreats.
4. Alongshore sediment flux occurs due to wave action in the surf zone, parameterized by the height and angle of incidence
of breaking waves. Gradients in alongshore transport dictate whether the shoreline advances or retreats.
====

image::shoreface_section.png[title="Change in shoreline position viewed in schematic cross section. Planar beach sloepe extends down to the depth of the shoreface. Shoreface danvances or retreats across the shelf",width="300",align="center"]

=== Governing equation
The conservation equation for beach sediment expressed in terms of local coordinates states that the change in position of the shoreline latexmath:[d\eta], perpendicular to the local shoreline orientation latexmath:[s] through time latexmath:[t] is a function of the divergence of alongshore sediment flux latexmath:[Q_{ls}]:

latexmath:[\frac{d\eta}{dt} = f\left(\frac{dQ_{ls}}{ds}\right)]

The nature of the function is dependent on the geometry of shoreline cells, which in COVE are not rectilinear, but rather triangular, trapezoidal or polygonal. The change of shoreline position for such cells is calculated by inverting quadratic and cubic equations for the volume of sediment in these cells (see http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al., 2015]).

=== Alongshore Flux
Bulk alongshore sediment flux is driven by waves breaking on the shoreface. Typically in alongshore transport laws, flux depends on the height latexmath:[H_b]
and angle latexmath:[\alpha_b] of breaking waves. For example, in the simplest case of fine/medium sand, COVE uses the CERC equation:

latexmath:[Q_{ls} = K_{ls} H_b^{5\over2} \sin 2\alpha_b]

where latexmath:[K_{ls}] is a transport coefficient. The transport coefficient latexmath:[K_{ls}] may be modified to account for the size of beach material (latexmath:[D_{50}]). Calibration of this coefficient can be made from estimates of bulk alongshore transport or by calibration against a historical record of coastal change (e.g. http://www.earth-surf-dynam.net/2/295/2014/esurf-2-295-2014.html[Barkwith et al. 2014a]).

=== Cliff Erosion

Cliffs are represented in the model as a separate line. The cliffline and coastline interact to determine how wide the beach is locally. Eroded cliff material is provided to the adjacent beach and causes the shoreface to advance. Cliff erosion is controlled by beach width since a wider beach provide energy dissipation and protection from approaching waves. Figure X shows a schematic graph of this relationship, as well as a conceptual diagram of the representation and relationship of the cliff and the beach.

image::limber_cliff_retreat.png[title="Schematic illustration of retreating cliff and beach. Relationship between beach width and cliff retreat rate is humped and nonlinear. For thin beaches, cliff retreat increases with beach width due to increased availability of \"tools\" to aid erosion. Wider beaches cause reduced cliff retreat, protecting the cliff by dissipating wave energy (after Limber and Murray, 2011).",width="500",align="center"]

The result is that we can run simlutaions at decadal timescales to explore the interactions between coastal erosion and alongshore sediment dynamics. 

=== Model requirements

==== Data
- The model requires offshore (~10 m water depth) wave data. This can be obtained either from a wave buoy or preferably from distributed coastal area modelling predictions of wave conditions (e.g. http://fvcom.smast.umassd.edu/fvcom/[FVCOM] or http://www.swan.tudelft.nl/[SWAN]).
- The transport coefficient latexmath:[K_{ls}] may be modified to account for the size of beach material (latexmath:[D_{50}]). Calibration of this coefficient can be made from estimates of bulk alongshore transport or by calibration against a historical record of coastal change.
- Historical shoreline positions and legacy wave data allow training of the model to reproduce past geomorphic changes.

==== Boundary Conditions
* Offshore waves (see above).
* Coupling to sediment sources and sinks (e.g. river mouth, estuary).
* Human interaction with the coast (e.g. http://www.earth-surf-dynam.net/2/233/2014/[Barkwith et al. 2014b]):
** Nourishment can be provided to build out the shoreface
** Hard defences represented as immovable, cliffed shoreline
** Groin fields simulated by prescribing a minimum beach width

== Software Requirements

COVE is written in C++, partly for efficiency but also to allow us to take advantage of running ensembles of simulations on UNIX high performance computing (HPC) clusters. The code has been written and tested in a Linux/UNIX environment, but has not been tested on Mac or Windows (we will doing this soon). So for now, you`re going to need to be/get familiar with working at a command line interface. 

There are a number of software requirements to run the model and visualise the results.
====
* Linux/UNIX computer or virtual machine (e.g. Ubuntu)
* C++ compiler (e.g. GCC: the GNU Compiler Collection)
* Text editor (e.g. gedit, Notepad++)
* Python + Scipy, Numpy and Matplotlib packages
====

=== Linux/UNIX

If you do not already work in Linux or UNIX, then the easiest way to get started would be to use some virtualisation software such as https://www.virtualbox.org/[VirtualBox] or http://www.vmware.com/uk/products/player[VMWare Workstation Player]. VirtualBox is preferable since it is open source and free to use, but there are some minor advantages to using VMWare Player if you become a heavy user. We hope soon to provide a https://www.vagrantup.com/[Vagrant file] to make this process a bit more straight forward. For now, I recommend installing https://www.virtualbox.org/[VirtualBox], creating a new virtual machine, and installing http://www.ubuntu.com/desktop[Ubuntu] using a downloaded iso file.

==== Git

https://git-scm.com/[Git] is version control software. The model is stored in a repository on https://github.com/COVE-Model[github]. This allows us to track all of our updates and developments and avoid duplication. You can install git from the command line:
----
$ sudo apt-get install git
----
Getting to grips with git can be a steep learning curve at first. The https://help.github.com/articles/github-glossary/[github glossary] is useful for getting up to speed with the terminology, and I found a good https://www.git-tower.com/blog/git-cheat-sheet/[cheat sheet] for git commands.
 
==== C++ Compiler

If you are using a Linux machine (e.g. the recommended Ubuntu VM) then you should have the GNU Compiler Collection installed. Depending on your experience and whether your developing the model, the https://www.gnu.org/software/gdb/[GNU debugger] can also be helpful (should already be installed with GCC), not to mention http://valgrind.org/[Valgrind] (you probably know what you`re doing better than I do if you`re using Valgrind!). We will also need the make utility (this should also be ready installed). No additional C++ libraries are required at this stage.

==== Text editor

A text editor is required for viewing and editing both the main code and driver files (shorter bits of code that interact with and control the main model objects). Ubuntu ships with gedit, which I find works well once you install and activate some useful plugins.
----
$ sudo apt-get install gedit-plugins gedit-developer-plugins
----
Some of these can really increase productivity while writing code.

==== Python

Python is a programming language that is great for analysing and visualising data, and is used here to visualise the output of COVE and running further analyses on model results. Again Python comes preinstalled on Ubuntu, but you could also use it on Windows/Mac. The key package required is https://www.scipy.org/[SciPy] ("scientific python"), which includes NumPy and Matplotlib. These are included with Ubuntu`s preinstalled version of Python. If you are using Windows/Mac then we recommend installing a Python distribution such as https://www.continuum.io/why-anaconda[Anaconda].

=== Windows

We are experimenting with getting the model working using the http://www.codeblocks.org/home[Code::Blocks] IDE with http://www.mingw.org/[MinGW] (Minimalist GNU for Windows) compilers. The pair are available to install together http://sourceforge.net/projects/codeblocks/files/Binaries/16.01/Windows/codeblocks-16.01mingw-setup.exe[here]. More to follow.


== Download the model


The COVE code is under continuous development. As we publish scientific papers that use the model, we will provide release versions of the model code associated. The development version is maintained on https://github.com/COVE-Model/COVE[github].

=== Release version

Version 1.0.0 are available as https://github.com/mdhurst1/COVE/archive/1.0.0.tar.gz[tar.gz release version] and https://github.com/mdhurst1/COVE/archive/1.0.0.zip[.zip release version] as used by http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al. (2015)] to explore the sensitivity of crenulate-shaped bays to variation in wave climate. If using this version, once downloaded, extract the contents to an appropriate workspace and you`re ready to continue.

Alternatively, you can clone the release version directly from the repository by running the command:
----
$ git clone https://github.com/COVE-Model/COVE-v1.0.0.git
----

=== Development version

The model is under semi-continuous development (depending on other commitments) and thus the development version is not always going to be functioning and stable. If you wish to work with the latest developments we suggest that you mailto:martin.hurst@glasgow.ac.uk[get in touch] and work with us directly. 

== Getting Started

This chapter provides a brief overview of how to compile and run an example model, and plot the results using Python. For more indepth tutorials, see the later chapters.

=== Compiling the code

The code can be compiled in a Linux environment from the command line, using one of the makefiles. These are contained in the `driver_files` subdirectory. The driver files are C++ scripts that control the initiation, running and saving of a COVE model run. In this tutorial we will use the example for running a spiral bay as used in http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al. (2015)].

In a terminal, navigate to the `driver_files` subdirectory:
----
COVE$ cd driver_files
----
Compile COVE for running a spiral bay by launching the makefile:
----
COVE/driver_files$ make -f spiral_bay_make.make
----
This will create an executable `spiral_bay.out` which can be launched from the command line to run the model. First, let`s move the executable to the parent directory, and navigate to the same directory:
----
COVE/driver_files$ mv spiral_bay.out ..
COVE/driver_files$ cd ..
----

=== Running the model

The file spiral_bay.out generated by compiling the code can be launched from the command line:
----
COVE/driver_files$ ./spiral_bay.out
----
Running it in this way will result in it terminating with an error, which will tell you that the program requires a number of input arguments in order to run. In the spiral bay example, the offshore wave climate is represented with three Gaussian distributions, for wave period, height and direction. Each of these is described by a mean and standard deviation, and these are fed to the model as arguments. To run the model with mean wave period of 6 seconds, standard deviation 1 second, mean wave height 1 metre, standard deviation 0.1 metre, and mean wave direction 035^o and standard deviation 25^o:
----
COVE/driver_files$ ./spiral_bay.out 6 1 1. 0.1 35 25
----
The model should then run for fifty years. This example evolves a crenulate-shaped bay from a straight initial coastline between two fixed headlands or sea walls. Sediment is transported out of the model domain by alongshore sediment flux and the shoreline gradually adjusts to the distribution of wave directions. The bay eventually reaches a state of equilibrium where the net alongshore flux is close to zero everywhere. The model is setup to run for 100 years, more than enough time for an equilibrium bay configuration to form.

While running the model will print the current model time to screen, it may also print some other messages, particularly including intersections in the coastline. The intersection analysis detects when the coastline intersects itself, such as when it erodes back behind the headland. Once this has happened the coastline is prevented from eroding any further.

=== Plotting the results
We make plots of the resulting coastline evolution using the python http://matplotlib.org/[matplotlib] library. To use them you will need a python IDE such as http://pythonhosted.org/spyder/[Spyder]. A series of plotting functions are included in the subdirectory `plotting_functions`. To plot the results of your spiral bay model run, open the file `plot_coastline_evolution_figure.py` in your favourite python IDE, and run. You should get the following figure:

.Example model output for a spiral bay showing the evolution of the bay through time from a starting condition of a straight coastline pinned by two headlands/sea walls. Model evolves to a condition of equilibrium where the coastal morphology changes little through time. 
image::spiral_bay_example.png[width="500",align="center"]

Additionally, below will be a link to a video of a spiral bay evolving, which will be hosted on Vimeo once I have time to work out how to do it (MDH).

== Example model runs

In this chapter we will look in detail at how the model is setup to perform a number of different example experiments. First we will look at the evolution of spiral bays from an initially straight coast line bound by sea walls or headlands, as used in http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract[Hurst et al. (2015)]. Next we will look at an example of an initially straight coastline using a periodic boundary condition subject to a mixture of low and high angle incidence offshore waves that generate hgih-angle wave instability, similar to the experiments of http://onlinelibrary.wiley.com/doi/10.1029/2005JF000422/abstract[Ashton and Murray, 2006]. Finally we will look at an example setup for a real stretch of cliffed coastline, using a stretch of the Suffolk coastline between Lowestoft and Southwold, which includes the interesting coastal foreland Benacre Ness. Hopefully this will give you some hands on guided experience of how to set the model up and how it behaves under different wave and boundary conditions.

=== Spiral bays

Let's look at how the model is set up to simulate the formation and evolution of crenulate-shaped bays (also known as spiral, log-spiral, zeta bays). To do so, we will open up the appropriate driver file and work through it to understand how the simulations are set up and what the model is doing.

==== The driver file

The driver file `spiral_bay_driver.cpp` can be found in the `driver_files` subdirectory. You can navigate to it and open in a text editor from the command line with:
----
$ cd driver_files
$ gedit spiral_bay_driver.cpp &
----
or open it from the explorer window.

OK, let's look at the driver file. There are some helpful comments that are ignored when we run the program, these start with "//" or are in blocks "/\*" to "*/". At the top of the file there are some `#include` statements that allow the program access to some libraries we will be using, including the model`s main coastline and waveclimate objects.

==== Setting up the wave climate

The spiral_bay_driver uses a Guassian representation of the wave climate. The parameters to set up the wave climate are required as input arguments at runtime. The wave climate is defined by a _mean_ and _standard deviation_ value for:

* Wave period latexmath:[T]
* Wave height latexmath:[H_0]
* Wave direction latexmath:[\theta_0]

and hence 6 input arguments are required. The driver file runs a check at the start to make sure it has the correct number of arguments, and will terminate with an error message if not.

In order to initialise the wave climate the 6 input arguments first are assigned to 6 variables:

[source,c++]
----
//Declare parameter for wave conditions
 double OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveDirection, 
        OffshoreStDWaveDirection, OffshoreMeanWaveHeight, OffshoreStDWaveHeight;
----

and the corresponding input arguments are converted from character sequences to numerical values and passed to these variables.

The wave climate is initialised by declaring a `GuassianWaveClimate` object called `WaveClimate` and passing these variables as input arguments in the correct order.

[source,c++]
----
	// initialise the wave climate
	GaussianWaveClimate WaveClimate = GaussianWaveClimate(	OffshoreMeanWavePeriod,
		OffshoreStDWavePeriod, OffshoreMeanWaveDirection, OffshoreStDWaveDirection,
		OffshoreMeanWaveHeight, OffshoreStDWaveHeight);
----

We then also declare an individual wave object. This holds the period, height and direction of an individual wave `MyWave` which we later pass to the coastline object in order to drive coastal evolution. We will sample a wave from `WaveClimate` and pass it to `MyWave`

[source,c++]
----
	// declare an individual wave (this will be sampled from the wave climate object
	Wave MyWave = Wave();
	// Get a wave from thewave climate object
	MyWave = WaveClimate.Get_Wave();
----

==== Model run control parameters

Various parameters are required to control the length of the model run (in years), how often the coastline position is output to file (in years), how often to sample a new wave from the wave climate object (days), and how big the model timestep should be (days). We suggest leaving these as they are for now, but as you start customising model setup you may need to adjust them.

[source,c++]
----
	//declare time control paramters
	int EndTime = 50.;	// End time (years)
	double Time = 0.;	// Start Time (years)
	double PrintTimeDelta = 36.5/365.;	// how often to print coastline (years)
	double PrintTime = PrintTimeDelta;	// Print time (years)
		
	double WaveTimeDelta = 0.1;	// Frequency at which to sample new waves (days)
	double GetWaveTime = 0.0;	// Time to get a new wave (days)
	double TimeStep = 0.05;	// Time step (days)
	double MaxTimeStep = 0.05;	// Maximum timestep (days)	
	double TempTime;	// Copies TimeDelta, allows adaptive timestep in a crude way
----

==== Initialise the model

The spiral bay model is initialised as a straight coast with fixed boundaries at each end of the coast line. In order to generate the coastline object, we need to prescribe some attributes that dictate the properties of the generated coast, which we will pass to the new Coastline object when we declare it.

[source,c++]
----
//initialise coast as straight line with low amp noise
int MeanNodeSpacing = 50; 	// in metres
double CoastLength = 2000;	// in metres
double Trend = 140.;	// in degrees
	
//boundary conditions are fixed
int StartBoundary = 2;
int EndBoundary = 2;		
----

* `MeanNodeSpacing` sets approximately how widely spaced the Coastline cells will be. It is a mean value, because as the model evolves, nodes might get closer together or further apart, and nodes will be dynamically added or destroyed accordingly in order to maintain this average. 
* `CoastLength` is the length of the coastline between the fixed (or otherwise) end nodes.
* `Trend` is the orientation (azimuth) that the straight coastline should extend in.

NOTE: The sea is always on the left side of the vector, so imagine you are standing at node '[0]' looking down the vector. If the `Trend` is 140^o^ then the sea is to the nort-east and the land to the south-west.

OK now that we have these variables in place we can go ahead and declare the Coastline object.

[source,c++]
----
//initialise the coastline as a straight line
Coastline CoastVector = Coastline(MeanNodeSpacing, CoastLength, Trend, StartBoundary, 
	EndBoundary);
	
//Initialise an empty/dummy cliffline object here
Cliffline CliffVector;
----

We declare a `Coastline` object whech we have called `CoastVector`, this is our coast, and all of its morphological properties are stored internally within the object. We provide the input arguments to the call in the order listed. 

Note there is also a call to declare a `Cliffline` object called `CliffVector`. It has no input arguments and therefore generates an empty `Cliffline` object (i.e. there is no actual cliff line inside it). Our spiral bay experiments don`t require a cliffline object so that is OK, but this declaration is required to keep the model happy (it needs to be able to look at a cliff to know it doesn`t really exist, it`s a dummy cliff). Don`t worry about this for now, this will generate a warning when we come to run the model but we are OK to ignore it.

Finally, for our spiral bay runs, we want to allow some simple rules for the refreaction and diffraction of waves behind coastal obstructions to be operating. To do this we need to set a flag within the `Coastline` object, 1 = on, 0 = off. 

[source,c++]
----
// Allow refraction/diffraction rules
int RefDiffFlag = 1;
CoastVector.SetRefDiffFlag(RefDiffFlag);
----

Finally, before we run the main model loop, we'll write the initial conditions to file:

[source,c++]
----
// loop through time and evolve the coast
CoastVector.WriteCoast(WriteCoastFile, Time);
----

==== Main model loop

We're all set up and ready to go! The model loop is pretty simple really, first grab a new wave from the wave climate, second pass it to the `Coastline` object when calling the `TransportSediment` function, third print the coordinates of the `Coastline` to file. 

The model evolves until the `Time` exceeds the prescribed `EndTime`:

[source,c++]
----
while (Time < EndTime)
{
	...	
----

We grab a new wave from the wave climate if it's time (`GetWaveTime` depends on `WaveTimeDelta` which sets how often we get a new wave):

[source,c++]
----
//Get a new wave?
if (Time > GetWaveTime) 
{
	MyWave = WaveClimate.Get_Wave();
	GetWaveTime += WaveTimeDelta/365.;
}
----

Notice that `GetWaveTime` is in years, but `WaveTimeDelta` is in days, so we divide through by 365 to convert.

Now we evolve the coast by calling the `Coastline` function `TransportSediment`. This requires three input arguments, `TimeStep` is the length of time that sediment is transported over, we also give it the wave `MyWave`, and finally the dummy Cliffline object `CliffVector`:

[source,c++]
----
//Evolve coast
CoastVector.TransportSediment(TimeStep, MyWave, CliffVector);
----

A whole lot of things happen inside this function (see a later section of this documentation that is yet to be written). The shoreline geometry is recalculated at each timestep. The wave is transformed from offshore to wave breaking conditions following linear wave theory, and any wave shadowing and refraction/diffraction are calculated. Alongshore sediment transport for each cell is calculated and the change in the volume of sediment in each cell calculated from the divergence of alongshore flux. The volume change is inverted for a change in the position of the coast and the position of each node is updated accordingly. The coastal geometry is updated for the next timestep.

There is a crude attempt written in here to allow adaptive timestepping. This hasn't fully been tested yet, and usually if it's called it's because there is a bug in the model not actually associated with the adaptive timestep. If you run into this problem please mailto:martin.hurst@glasgow.ac.uk[email me].

Finally, the model prints the updated _X_ and _Y_ coordinates to an output file. See Writing Results to File for details of the resulting file format.

==== Compile and Run

Compile COVE for running a spiral bay by launching the makefile:

----
COVE/driver_files$ make -f spiral_bay_make.make
----

The file spiral_bay.out generated by compiling the code can be launched from the command line. The program takes the wave climate parameters as inputs latexmath:[T_{mean}],latexmath:[T_{std}],latexmath:[H_{mean}],latexmath:[H_{std}],latexmath:[\theta_{mean}],latexmath:[\theta_{std}]:

----
COVE/driver_files$ ./spiral_bay.out 6 1 1. 0.1 35 25
----

The model should then run for fifty years. This example evolves a crenulate-shaped bay from a straight initial coastline between two fixed headlands or sea walls. Sediment is transported out of the model domain by alongshore sediment flux and the shoreline gradually adjusts to the distribution of wave directions. The bay eventually reaches a state of equilibrium where the net alongshore flux is close to zero everywhere. The model is setup to run for fifty years, more than enough time for an equilibrium bay configuration to form.

While running the model will print the current model time to screen, it may also print some other messages, particularly including intersections in the coastline. The intersection analysis detects when the coastline intersects itself, such as when it erodes back behind the headland. Once this has happened the coastline is prevented from eroding any further.

==== Plotting the results
A series of plotting functions are included in the subdirectory `plotting_functions`. To plot the results of your spiral bay model run, open the file `plot_coastline_evolution_figure.py` in your favourite python IDE, and run. You should get the following figure:

.Example model output for a spiral bay showing the evolution of the bay through time from a starting condition of a straight coastline pinned by two headlands/sea walls. Model evolves to a condition of equilibrium where the coastal morphology changes little through time. 
image::spiral_bay_example.png[width="500",align="center"]

=== Sand waves

==== The driver file

=== Real cliffed coast

Let's look at how to set the model up to run on a real stretch of cliffed coastline. The example we are going to look at is from the coast of Suffolk between Lowestoft and Southwold (see Figure X).

Insert figure here of study site.

This coastline experiences a bimodal wave climate, with waves coming out of the North Sea to the north east, and through the English Channel from the South.

We are interested in this stretch of coastline because at Kessingland there is a large coastal foreland called Benacre Ness that is migrating northward along the coast. It is called Benacre Ness because it used to sit in front of the Benacre estate, but has migrated northward and now stretches across the frontage of Kessingland. It has been estimated to extend northward at rates of 20-50 m y^-1^, despite the locally established view that alongshore sediment transport is directed from north to south.

==== The driver file


==== Input files

Using a real coastline, the model will require three input files in order to initialise the coast. A coastline _x-y_ file, a cliffline _x-y_ file and cliff type file. The coastline and cliffline _x-y_ files have the same format as the model output, consisting of a header line with two space-separated integers representing the start and end boundary conditions, followed by lines containing the _x_ and _y_ coordinates of the coastline, preceded by the time (see "Read a coast from file" in the "under the hood" section. The order that your _x_ and _y_ coordinates come in is very important. The model *ALWAYS* assumes that the sea is on the left side as it works its way down the coastline or cliffline vector. 

To be sure you get this correct, imagine you are standing at the first node on your coastline, looking towards the second node. The sea will be on the left of the line, and the land on the right. If this is backwards, you will get some very strange behaviour, because the model will ignore alot of waves (since they are coming from the land) and beach widths will be negative. If your first attempt at modelling a stretch of coastline blows up straight away, this is the first thing to check. We should probably write some error checking into the beach width calculator to flag negative values and warn you. This will get added in later.

The third file required is a cliff type file. This tells the model whether a cliff node can erode or is fixed (this can later be expanded to include different types of geology). Currently a value of 1 represents a fixed coast (e.g. defended by sea wall/revetment) and a value of 0 is a normal erodible cliff. The file format is a header line followed by two columns, one for the node index (`i=0` to `i=NoNodes-1`) and the second for the cliff type integer.

== Wave Climates

The model requires wave conditions to drive alongshore sediment transport. This is supplied in the form of a waveclimate object that the coastline model can interact with. For the purposes of this model, a wave climate consists of a timeseries of waves considered to be "offshore", that is to say the wave conditions recieved at the bottom of the shoreface. This time series comprises significant wave height latexmath:[H_0], wave period latexmath:[T] and wave direction latexmath:[\theta_0]. The waveclimate object can take a variety of guises, including both hypothetical and real wave climates. the model is most sensitive to variation in _wave direction_. Hypothetical wave climates include the U-A descripition of wave directions (Ashton & Murray, 2006) or a simple Gaussian distribution (Hurst et al., 2015). Real wave climates read in a timeseries of latexmath:[H_0], latexmath:[T] and latexmath:[\theta_0] data that might be collected from a nearby wave buoy deployment, or generated by a coastal area model such as http://fvcom.smast.umassd.edu/fvcom/[FVCOM] or http://www.swan.tudelft.nl/[SWAN].

=== Single wave

=== Gaussian wave climate

The `GuassianWaveClimate` object contains six parameters to describe distributions of Wave period latexmath:[T], Wave height latexmath:[H_0], and Wave direction latexmath:[\theta_0]. In order to initialise the wave climate in a driver file, 6 variables must be declared, and values assigned:

[source,c++]
----
//Declare parameter for wave conditions
double OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveDirection, 
	OffshoreStDWaveDirection, OffshoreMeanWaveHeight, OffshoreStDWaveHeight;
----

The wave climate is initialised by declaring a `GuassianWaveClimate` object called `WaveClimate` and passing these variables as input arguments in the correct order.

[source,c++]
----
// initialise the wave climate
GaussianWaveClimate WaveClimate = GaussianWaveClimate(OffshoreMeanWavePeriod,
	OffshoreStDWavePeriod, OffshoreMeanWaveDirection, OffshoreStDWaveDirection,
	OffshoreMeanWaveHeight, OffshoreStDWaveHeight);
----

We then also declare an individual wave object. This holds the period, height and direction of an individual wave `MyWave` which we later pass to the coastline object in order to drive coastal evolution. We will sample a wave from `WaveClimate` and pass it to `MyWave`

[source,c++]
----
// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();
----

This last line should appear in the main model loop to select new waves at the chosen frequency:

[source,c++]
----
while (Time < EndTime)
{
	//Get a new wave?
	if (Time > GetWaveTime) 
	{
		MyWave = WaveClimate.Get_Wave();
		GetWaveTime += WaveTimeDelta/365.;
	}
	
	...
	
----

=== Bimodal  wave climate

=== U-A wave climate

=== Real wave data

== Under the hood

=== Initialising a Coastline object

==== Read a Coastline from file

Input files for the position of the coast take the same format as output files. The first line is a header containing integer values for the `StartBoundary` and `EndBoundary` conditions. The next two lines are the X and Y coordinates of the line respectively, but both preceded by the time (in years). We use \| to indicate a white space delimiter here such as a space or tab.
----
StartBoundary | EndBoundary
Time | X[0] | X[1] | X[2] =====> X[NoNodes]
Time | Y[0] | Y[1] | Y[2] =====> Y[NoNodes]
----
So for example, a 5 metre long coastline with fixed boundary conditions oriented at 135^o with a latexmath:[sqrt{2}] node spacing, at `Time = 0` would have an input file:
----
2 2
0 0 1 2 3 4 5
0 0 1 2 3 4 5
----

=== Initialising a Cliffline object

=== Boundary Conditions

The model is a single line. The start and end of the line can be handled in different ways. At the moment, we have two possible boundary conditions, which are assigned by setting the `StartBoundary` and `EndBoundary` parameters when initialising the coastline, or putting these in the header of an input file if initialising the coastline with an existing coastline output file (or real coastline). The boundary conditions are set by an integer as:
1. Periodic boundary conditions: the start of the line is also the end, and sediment can be passed \"round the back\" e.g. an island.
2. Fixed boundary conditions the first and last two nodes/cells in the model are fixed and immovable.


=== Writing results to file

The `Coastline` object writes the position of the coast to a text file with a name provided in the call `WriteCoastFile`. The `Time` must also be passed:

[source,c++]
----
//loop through time and evolve the coast
CoastVector.WriteCoast(WriteCoastFile, Time);
----

The file format is the same as for reading a coast from a text file. The first line is a header containing integer values for the `StartBoundary` and `EndBoundary` conditions. The next two lines are the X and Y coordinates of the line respectively, but both preceded by the time (in years). We use \| to indicate a white space delimiter here such as a space or tab.
----
StartBoundary | EndBoundary
Time | X[0] | X[1] | X[2] =====> X[NoNodes]
Time | Y[0] | Y[1] | Y[2] =====> Y[NoNodes]
----
So for example, a 5 metre long coastline with fixed boundary conditions oriented at 135^o with a latexmath:[sqrt{2}] node spacing, at `Time = 1`, that has not changed since `Time = 0` would have an input file:
----
2 2
0 0 1 2 3 4 5
0 0 1 2 3 4 5
1 0 1 2 3 4 5
1 0 1 2 3 4 5
----

More details to follow. See the [Doxygen documentation] for the time being.

== Ensemble mode

Details to follow.

== References

[small]#Ashton, A. D., and A. B. Murray (2006), High-angle wave instability and emergent shoreline shapes: 1. Modeling of sand waves, flying spits, and capes, _J. Geophys. Res._,
111, F04011, doi: http://dx.doi.org/10.1029/2005JF000422[10.1029/2005JF000422].#

[small]#Barkwith, A., Thomas, C. W., Limber, P. W., Ellis, M. A., and Murray, A. B. (2014a), Coastal vulnerability of a pinned, soft-cliff coastline – Part I: Assessing the natural sensitivity to wave climate, _Earth Surf. Dynam._, 2, 295-308, doi: http://dx.doi.org/10.5194/esurf-2-295-2014[10.5194/esurf-2-295-2014].#

[small]#Barkwith, A., Hurst, M. D., Thomas, C. W., Ellis, M. A., Limber, P. L., and Murray, A. B. (2014b) Coastal vulnerability of a pinned, soft-cliff coastline, II: assessing the influence of sea walls on future morphology, Earth Surf. Dynam., 2, 233-242, doi: http://dx.doi.org/10.5194/esurf-2-233-2014[10.5194/esurf-2-233-2014].#

[small]#Hurst, M. D., A. Barkwith, M. A. Ellis, C. W. Thomas, and A. B. Murray (2015), Exploring the sensitivities of crenulate bay shorelines to wave climates using a new vector-based one-line model, _J. Geophys. Res. Earth Surf._, 120, 2586–2608, doi: http://dx.doi.org/10.1002/2015JF003704[10.1002/2015JF003704].#

[small]#Limber, P. W. and A. Brad Murray (2011) Beach and sea-cliff dynamics as a driver of long-term rocky coastline evolution and stability, _Geology_, 39, 1147-1150, doi: http://dx.doi.org/10.1130/G32315.1[10.1130/G32315.1]#


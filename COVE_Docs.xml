<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>COVE</title>
<subtitle>Coastal Vector Evolution Model</subtitle>
<date>2016-07-08</date>
<author>
<personname>
<firstname>Martin D. Hurst &lt;Martin.Hurst@glasgow.ac.uk&gt;, Andrew Barkwith, Christopher W. Thomas, Michael A. Ellis, A. Brad Murray</firstname>
</personname>
</author>
<authorinitials>M</authorinitials>
</info>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images//COVE_logo.png" contentwidth="100" contentdepth="100"/>
</imageobject>
<textobject><phrase>COVE logo</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_introduction">
<title>Introduction</title>
<simpara>This is the documentation for COVE, the COastal Vector Evolution model - a vector-based one-line coastal evolution model. The model was presented and used in a <link xl:href="http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract">paper</link> on the evolution of crenulate bays published in the <emphasis>Journal of Geophysical Research Earth Surface</emphasis> (<link xl:href="http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract">Hurst et al., 2015</link>). The model is intended for research purposes, exploring coastal behaviour and sensitiviy.</simpara>
<simpara>The model is intended for research purposes. It is released under a <link xl:href="http://www.gnu.org/licenses/gpl-3.0.en.html">GNU General Public Licence</link>. If you are interested in working with COVE, we would encourage you to <link xl:href="mailto:martin.hurst@glasgow.ac.uk">get in touch</link> and work with us. In this introduction, we will give a brief overview of the science behind the model.</simpara>
<simpara>Reference documentation for the code has been generated using Doxygen and the resulting reference material can be accessed at <link xl:href="https://COVE-model.github.io/COVE/documentation/html/index.html">COVE Doxygen Documentation</link>.</simpara>
<simpara><emphasis role="strong">SUMMARY</emphasis></simpara>
<informalexample>
<itemizedlist>
<listitem>
<simpara>COVE is a ‘one-line’ type shoreline evolution model.</simpara>
</listitem>
<listitem>
<simpara>Application at spatial scales of kms to tens of kms, over decadal to millennial timescales.</simpara>
</listitem>
<listitem>
<simpara>Coastal change is driven by gradients in wave-generated alongshore sediment transport.</simpara>
</listitem>
<listitem>
<simpara>Alongshore sediment transport driven by the height and angle of breaking waves.</simpara>
</listitem>
<listitem>
<simpara>Retreat of cliffs governed by beach interaction (protection vs tools).</simpara>
</listitem>
</itemizedlist>
</informalexample>
<simpara><?asciidoc-pagebreak?></simpara>
<section xml:id="_overview">
<title>Overview</title>
<simpara>The COVE model is a special case of a ‘one-line’ model designed to handle complex coastline geometries, with high planform curvature shorelines (<link xl:href="http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract">Hurst et al., 2015</link>). The shoreline is represented by a single line (or contour) that advances or retreats depending on the net alongshore sediment flux. COVE is now actually a two-line model because a second line representing coastal cliffs interacts with the shoreline, eroding to provide beach sediment. One-line models make a number of simplifying assumptions to conceptualise the coastline allowing the ‘one-line’ representation of the coastline:</simpara>
<simpara><emphasis role="strong">ASSUMPTIONS</emphasis></simpara>
<informalexample>
<orderedlist numeration="arabic">
<listitem>
<simpara>Short-term cross-shore variations due to storms or rip currents are considered temporary perturbations to the long-term
trajectory of coastal change (i.e. the shoreface recovers rapidly from storm-driven cross-shore transport).</simpara>
</listitem>
<listitem>
<simpara>The beach profile is thus assumed to maintain a constant time-averaged form (Fig. 1), implying that depth contours are
shore-parallel and therefore allows the coast to be represented by a single contour line.</simpara>
</listitem>
<listitem>
<simpara>Alongshore sediment transport occurs primarily in the surf zone, and cross-shore sediment transport acts to maintain the
equilibrium shoreface as it advances /retreats.</simpara>
</listitem>
<listitem>
<simpara>Alongshore sediment flux occurs due to wave action in the surf zone, parameterized by the height and angle of incidence
of breaking waves. Gradients in alongshore transport dictate whether the shoreline advances or retreats.</simpara>
</listitem>
</orderedlist>
</informalexample>
<figure>
<title>Change in shoreline position viewed in schematic cross section. Planar beach sloepe extends down to the depth of the shoreface. Shoreface advances or retreats across the shelf</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//shoreface_section.png" contentwidth="300" align="center"/>
</imageobject>
<textobject><phrase>shoreface section</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Schematic planform diagram of a coastline with shore-parallel depth contours, as assumed in one-line models</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//parallel_contours.png" contentwidth="300" align="center"/>
</imageobject>
<textobject><phrase>parallel contours</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_governing_equation">
<title>Governing equation</title>
<simpara>Previous one-line models have cast the conservation of sediment in a gridded cartesian framework, relative to the general orientation of the coastline (the <inlineequation><alt><![CDATA[x]]></alt><mathphrase><![CDATA[x]]></mathphrase></inlineequation>-coordinate). The result is that coastal cells are rectangular and either prograde or regress perpendicular to the general orientation of the coastline (the <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation>-coordinate):</simpara>
<simpara>image::rectangular_cells.png[title="Schematic planform diagram of a coastline with rectilinear cells orientated perpendicular to the general trend of the shoreline, as assumed in one-line models. The shoreline either advances or retreats in the <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> direction",width="300",align="center"]</simpara>
<simpara>Given the assumption that the evolution of the coastline is driven by gradients in alongshore sediment transport, the conservation equation for this setup (e.g. Ashton and Murray, 2006) states that the change of position of the coast <inlineequation><alt><![CDATA[y]]></alt><mathphrase><![CDATA[y]]></mathphrase></inlineequation> is equal to the divergence in alongshore sediment flux <inlineequation><alt><![CDATA[Q_{ls}]]></alt><mathphrase><![CDATA[Q_{ls}]]></mathphrase></inlineequation> divided by the shoreface depth <inlineequation><alt><![CDATA[D_{sf}]]></alt><mathphrase><![CDATA[D_{sf}]]></mathphrase></inlineequation>:</simpara>
<simpara><inlineequation><alt><![CDATA[\frac{dy}{dt} = \frac{1}{D_{sf}}\left(\frac{dQ_{ls}}{dx}\right)]]></alt><mathphrase><![CDATA[\frac{dy}{dt} = \frac{1}{D_{sf}}\left(\frac{dQ_{ls}}{dx}\right)]]></mathphrase></inlineequation></simpara>
<simpara>However, when the shoreline has high planform curvature, this equation becomes difficult to apply as the principle of conservation of mass is violated. Ashton and Murray (2006) dealt with this problem through the use of a cellular model. Alternatively, it has been proposed to use a local coordinate system (LeBlond, 1972; Kaergaard and Fredsoe, 2013).</simpara>
<section xml:id="_using_a_local_coordinate_system">
<title>Using a local coordinate system</title>
<simpara>The conservation equation for beach sediment expressed in terms of local coordinates states that the change in position of the shoreline <inlineequation><alt><![CDATA[d\eta]]></alt><mathphrase><![CDATA[d\eta]]></mathphrase></inlineequation>, perpendicular to the local shoreline orientation <inlineequation><alt><![CDATA[s]]></alt><mathphrase><![CDATA[s]]></mathphrase></inlineequation> through time <inlineequation><alt><![CDATA[t]]></alt><mathphrase><![CDATA[t]]></mathphrase></inlineequation> is a function of the divergence of alongshore sediment flux <inlineequation><alt><![CDATA[Q_{ls}]]></alt><mathphrase><![CDATA[Q_{ls}]]></mathphrase></inlineequation>:</simpara>
<simpara><inlineequation><alt><![CDATA[\frac{d\eta}{dt} = f\left(\frac{dQ_{ls}}{ds}\right)]]></alt><mathphrase><![CDATA[\frac{d\eta}{dt} = f\left(\frac{dQ_{ls}}{ds}\right)]]></mathphrase></inlineequation></simpara>
</section>
</section>
<section xml:id="_cell_building_routine">
<title>Cell building routine</title>
<section xml:id="_irregular_shoreline_cells">
<title>Irregular shoreline cells</title>
<simpara>The nature of the conservation of mass function is dependent on the geometry of shoreline cells. If we were to use rectilinear cells we would violate mass conservation because the cells would either diverge or converge offshore, depending on the planform curvature of the shoreline (i.e. convex offshore vs concave offshore respectively).</simpara>
<figure>
<title>Schematic planform diagram of a coastline where rectilinear cells, orientated perpendicular to the local coastline orientation, are assumed to extend down to the bottom of the shoreface. Some cells diverge where the shoreline is convex-seaward, whilst others overlap where the shoreline is concave.</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//mass_balance_errors.png" contentwidth="300" align="center"/>
</imageobject>
<textobject><phrase>mass balance errors</phrase></textobject>
</mediaobject>
</figure>
<simpara>In COVE, coastline cells are not rectilinear, but rather triangular, trapezoidal or polygonal. The change of shoreline position for such cells is calculated by inverting quadratic and cubic equations for the volume of sediment in these cells (see <link xl:href="http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract">Hurst et al., 2015</link>).</simpara>
</section>
<section xml:id="_cell_geometry">
<title>Cell geometry</title>
<simpara>Each coastline node has an orientation calculated as the azimuth angle of a vector connecting the two adjacent nodes. Cell edges seperating adjacent cells have an orientation that is perpendicular to imaginary lines between the node of interest and each adjacent node, and they bisect these lines. The cell is thus defined by the cell width at the shoreline <inlineequation><alt><![CDATA[W_0]]></alt><mathphrase><![CDATA[W_0]]></mathphrase></inlineequation>, and two angles describing the difference between the cell orientation and the cell boundary orientations <inlineequation><alt><![CDATA[\eta_1]]></alt><mathphrase><![CDATA[\eta_1]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[\eta_2]]></alt><mathphrase><![CDATA[\eta_2]]></mathphrase></inlineequation> for the upcoast and downcoast boundaries respectively.</simpara>
<figure>
<title>Schematic planform diagram of a coastal cell built from the arrangement of coastal nodes.</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//cell_geometry.png" contentwidth="300" align="center"/>
</imageobject>
<textobject><phrase>cell geometry</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_mesh_building_algorithm">
<title>Mesh building algorithm</title>
<simpara>The model builds coastal cells by projecting offshore the cell edges defined above. The procedure is as follows:
. A priority queue is built so that cells with the largest value of latexmath:[\eta_1+eta_2] are prioritised.
. Starting with the most acute, cell boundaries are projected offshore until&#8230;&#8203;
.. They intersect, in which case the cell is closed and a new boundary for adjacent cells will be created from the intersection point, and adjacent cells will be added to the priority queue again; or
.. The bottom of the shoreface <inlineequation><alt><![CDATA[D_{sf}]]></alt><mathphrase><![CDATA[D_{sf}]]></mathphrase></inlineequation> is reached and the cell is closed by a straight line across the shoreface defining the bottom of the shoreface.
. The procedure continues until all cells have been meshed.</simpara>
<figure>
<title>Plan view of a shoreline with cells built using the mesh building algorithm. Coastal cells built by projecting cell boundaries seaward until they intersect, starting from the most concave-seaward cell. The order in which cell building proceeds is numbered. When cell boundaries intersect, the mean orientation of contributing cell edges determines the direction in which the projection continues.</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//meshing.png" contentwidth="300" align="center"/>
</imageobject>
<textobject><phrase>meshing</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section xml:id="_alongshore_flux">
<title>Alongshore Flux</title>
<simpara>Bulk alongshore sediment flux is driven by waves breaking on the shoreface. Typically in alongshore transport laws, flux depends on the height <inlineequation><alt><![CDATA[H_b]]></alt><mathphrase><![CDATA[H_b]]></mathphrase></inlineequation>
and angle <inlineequation><alt><![CDATA[\alpha_b]]></alt><mathphrase><![CDATA[\alpha_b]]></mathphrase></inlineequation> of breaking waves. For example, in the simplest case of fine/medium sand, COVE uses the CERC equation:</simpara>
<simpara><inlineequation><alt><![CDATA[Q_{ls} = K_{ls} H_b^{5\over2} \sin 2\alpha_b]]></alt><mathphrase><![CDATA[Q_{ls} = K_{ls} H_b^{5\over2} \sin 2\alpha_b]]></mathphrase></inlineequation></simpara>
<simpara>where <inlineequation><alt><![CDATA[K_{ls}]]></alt><mathphrase><![CDATA[K_{ls}]]></mathphrase></inlineequation> is a transport coefficient. The transport coefficient <inlineequation><alt><![CDATA[K_{ls}]]></alt><mathphrase><![CDATA[K_{ls}]]></mathphrase></inlineequation> may be modified to account for the size of beach material (<inlineequation><alt><![CDATA[D_{50}]]></alt><mathphrase><![CDATA[D_{50}]]></mathphrase></inlineequation>). Calibration of this coefficient can be made from estimates of bulk alongshore transport or by calibration against a historical record of coastal change (e.g. <link xl:href="http://www.earth-surf-dynam.net/2/295/2014/esurf-2-295-2014.html">Barkwith et al. 2014a</link>).</simpara>
</section>
<section xml:id="_cliff_erosion">
<title>Cliff Erosion</title>
<simpara>Cliffs are represented in the model as a separate line. The cliffline and coastline interact to determine how wide the beach is locally. Eroded cliff material is provided to the adjacent beach and causes the shoreface to advance. Cliff erosion is controlled by beach width since a wider beach provide energy dissipation and protection from approaching waves. Figure 2 shows a schematic graph of this relationship, as well as a conceptual diagram of the representation and relationship of the cliff and the beach.</simpara>
<figure>
<title>Schematic illustration of retreating cliff and beach. Relationship between beach width and cliff retreat rate is humped and nonlinear. For thin beaches, cliff retreat increases with beach width due to increased availability of "tools" to aid erosion. Wider beaches cause reduced cliff retreat, protecting the cliff by dissipating wave energy (after Limber and Murray, 2011).</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//limber_cliff_retreat.png" contentwidth="500" align="center"/>
</imageobject>
<textobject><phrase>limber cliff retreat</phrase></textobject>
</mediaobject>
</figure>
<simpara>The result is that we can run simlutaions at decadal timescales to explore the interactions between coastal erosion and alongshore sediment dynamics.</simpara>
</section>
<section xml:id="_model_requirements">
<title>Model requirements</title>
<section xml:id="_data">
<title>Data</title>
<itemizedlist>
<listitem>
<simpara>The model requires offshore (~10 m water depth) wave data. This can be obtained either from a wave buoy or preferably from distributed coastal area modelling predictions of wave conditions (e.g. <link xl:href="http://fvcom.smast.umassd.edu/fvcom/">FVCOM</link> or <link xl:href="http://www.swan.tudelft.nl/">SWAN</link>).</simpara>
</listitem>
<listitem>
<simpara>The transport coefficient <inlineequation><alt><![CDATA[K_{ls}]]></alt><mathphrase><![CDATA[K_{ls}]]></mathphrase></inlineequation> may be modified to account for the size of beach material (<inlineequation><alt><![CDATA[D_{50}]]></alt><mathphrase><![CDATA[D_{50}]]></mathphrase></inlineequation>). Calibration of this coefficient can be made from estimates of bulk alongshore transport or by calibration against a historical record of coastal change.</simpara>
</listitem>
<listitem>
<simpara>Historical shoreline positions and legacy wave data allow training of the model to reproduce past geomorphic changes.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_boundary_conditions">
<title>Boundary Conditions</title>
<itemizedlist>
<listitem>
<simpara>Offshore waves (see above).</simpara>
</listitem>
<listitem>
<simpara>Coupling to sediment sources and sinks (e.g. river mouth, estuary).</simpara>
</listitem>
<listitem>
<simpara>Human interaction with the coast (e.g. <link xl:href="http://www.earth-surf-dynam.net/2/233/2014/">Barkwith et al. 2014b</link>):</simpara>
<itemizedlist>
<listitem>
<simpara>Nourishment can be provided to build out the shoreface</simpara>
</listitem>
<listitem>
<simpara>Hard defences represented as immovable, cliffed shoreline</simpara>
</listitem>
<listitem>
<simpara>Groin fields simulated by prescribing a minimum beach width</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="_software_requirements">
<title>Software Requirements</title>
<simpara>COVE is written in C++, partly for efficiency but also to allow us to take advantage of running ensembles of simulations on UNIX high performance computing (HPC) clusters. The code has been written and tested extensively in a Linux/UNIX environment, and has also been compiled and run on Windows using Code::Blocks, but has not been tested on Mac. So for now, you`re going to need to be/get familiar with working at a command line interface.</simpara>
<simpara>There are a number of software requirements to run the model and visualise the results.</simpara>
<informalexample>
<itemizedlist>
<listitem>
<simpara>C++ compiler (e.g. GCC: the GNU Compiler Collection)</simpara>
</listitem>
<listitem>
<simpara>Text editor (e.g. gedit, Notepad++)</simpara>
</listitem>
<listitem>
<simpara>Python + Scipy, Numpy and Matplotlib packages</simpara>
</listitem>
</itemizedlist>
</informalexample>
<section xml:id="_linux_unix">
<title>Linux/UNIX</title>
<simpara>If you do not already work in Linux or UNIX, then the easiest way to get started would be to use some virtualisation software such as <link xl:href="https://www.virtualbox.org/">VirtualBox</link> or <link xl:href="http://www.vmware.com/uk/products/player">VMWare Workstation Player</link>. VirtualBox is preferable since it is open source and free to use, but there are some minor advantages to using VMWare Player if you become a heavy user. We hope soon to provide a <link xl:href="https://www.vagrantup.com/">Vagrant file</link> to make this process a bit more straight forward. For now, I recommend installing <link xl:href="https://www.virtualbox.org/">VirtualBox</link>, creating a new virtual machine, and installing <link xl:href="http://www.ubuntu.com/desktop">Ubuntu</link> using a downloaded iso file.</simpara>
<section xml:id="_git">
<title>Git</title>
<simpara><link xl:href="https://git-scm.com/">Git</link> is version control software. The model is stored in a repository on <link xl:href="https://github.com/COVE-Model">github</link>. This allows us to track all of our updates and developments and avoid duplication. You can install git from the command line:</simpara>
<screen>$ sudo apt-get install git</screen>
<simpara>Getting to grips with git can be a steep learning curve at first. The <link xl:href="https://help.github.com/articles/github-glossary/">github glossary</link> is useful for getting up to speed with the terminology, and I found a good <link xl:href="https://www.git-tower.com/blog/git-cheat-sheet/">cheat sheet</link> for git commands.</simpara>
</section>
<section xml:id="_c_compiler">
<title>C++ Compiler</title>
<simpara>If you are using a Linux machine (e.g. the recommended Ubuntu VM) then you should have the GNU Compiler Collection installed. Depending on your experience and whether your developing the model, the <link xl:href="https://www.gnu.org/software/gdb/">GNU debugger</link> can also be helpful (should already be installed with GCC), not to mention <link xl:href="http://valgrind.org/">Valgrind</link> (you probably know what you`re doing better than I do if you`re using Valgrind!). We will also need the make utility (this should also be ready installed). No additional C++ libraries are required at this stage.</simpara>
</section>
<section xml:id="_text_editor">
<title>Text editor</title>
<simpara>A text editor is required for viewing and editing both the main code and driver files (shorter bits of code that interact with and control the main model objects). Ubuntu ships with gedit, which I find works well once you install and activate some useful plugins.</simpara>
<screen>$ sudo apt-get install gedit-plugins gedit-developer-plugins</screen>
<simpara>Some of these can really increase productivity while writing code.</simpara>
</section>
<section xml:id="_python">
<title>Python</title>
<simpara>Python is a programming language that is great for analysing and visualising data, and is used here to visualise the output of COVE and running further analyses on model results. Again Python comes preinstalled on Ubuntu, but you could also use it on Windows/Mac. The key package required is <link xl:href="https://www.scipy.org/">SciPy</link> ("scientific python"), which includes NumPy and Matplotlib. These are included with Ubuntu`s preinstalled version of Python.</simpara>
<simpara>It is recommended that you install a Python IDE in order to run plotting functions and perform post-processing. The preferred IDE is <link xl:href="https://pythonhosted.org/spyder/">Spyder</link>. The easiest way to install is from the command line:</simpara>
<screen>$ sudo apt-get install spyder</screen>
</section>
<section xml:id="_mencoder">
<title>Mencoder</title>
<simpara><link xl:href="https://en.wikipedia.org/wiki/MEncoder">Mencoder</link> is a command line tool that is part of <link xl:href="http://www.mplayerhq.hu/design7/news.html">MPlayer</link> that allows you to encode video files. We use it here to stich together still images of model output in order to create videos of our model coastlines evolving. To install, from the command line, type:</simpara>
<informalexample>
<simpara>$ sudo apt install mencoder</simpara>
</informalexample>
</section>
</section>
<section xml:id="_windows">
<title>Windows</title>
<simpara>Alternatively, if you prefer to continue using Windows, it is possible to get the model working using the <link xl:href="http://www.codeblocks.org/home">Code::Blocks</link> IDE with <link xl:href="http://www.mingw.org/">MinGW</link> (Minimalist GNU for Windows) compilers. The pair are available to install together <link xl:href="http://sourceforge.net/projects/codeblocks/files/Binaries/16.01/Windows/">here</link>. We have not tested COVE extensively in this environment but the <link linkend="Examples">examples</link> below all compile and run correctly from Code::Blocks.</simpara>
<section xml:id="_code_blocks">
<title>Code::Blocks</title>
<simpara>Code::Blocks is an IDE with built in compiler and debugger functionality. Head to the <link xl:href="http://sourceforge.net/projects/codeblocks/files/Binaries/16.01/Windows/">download page</link> for Code::Blocks and select the binary executable with the suffix "&#8230;&#8203;mingw_setup.exe". Run through the installation procedure selecting the default options. Once finished, Code::Blocks should load automatically.</simpara>
</section>
<section xml:id="_python_2">
<title>Python</title>
<simpara>Python is a programming language that is great for analysing and visualising data, and is used here to visualise the output of COVE and running further analyses on model results. The key package required is <link xl:href="https://www.scipy.org/">SciPy</link> ("scientific python"), which includes NumPy and Matplotlib. If you are using Windows/Mac then we recommend installing a Python distribution such as <link xl:href="https://www.continuum.io/why-anaconda">Anaconda</link>.</simpara>
<warning>
<simpara>If you have ARCGIS 10.x installed then Python v2.7 will already be installed on your computer. You can either try to build on this installation by adding the packages you need, when you need them (www.lfd.uci.edu/~gohlke/pythonlibs/[This collection] is a good resource for Python Extension binary packages), or work with two versions of Python by installing a second, such as through <link xl:href="https://www.continuum.io/why-anaconda">Anaconda</link>.</simpara>
</warning>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
</section>
<section xml:id="_download_the_model">
<title>Download the model</title>
<simpara>The COVE code is under continuous development. As we publish scientific papers that use the model, we will provide release versions of the model code associated. The development version is maintained on <link xl:href="https://github.com/COVE-Model/COVE">github</link>.</simpara>
<section xml:id="_release_version">
<title>Release version</title>
<simpara>Version 1.0.0 are available as <link xl:href="https://github.com/mdhurst1/COVE/archive/1.0.0.tar.gz">tar.gz release version</link> and <link xl:href="https://github.com/mdhurst1/COVE/archive/1.0.0.zip">.zip release version</link> as used by <link xl:href="http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract">Hurst et al. (2015)</link> to explore the sensitivity of crenulate-shaped bays to variation in wave climate. If using this version, once downloaded, extract the contents to an appropriate workspace and you`re ready to continue.</simpara>
<simpara>Alternatively, you can clone the release version directly from the repository by running the command:</simpara>
<screen>$ git clone https://github.com/COVE-Model/COVE-v1.0.0.git</screen>
</section>
<section xml:id="_development_version">
<title>Development version</title>
<simpara>The model is under semi-continuous development (depending on other commitments) and thus the development version is not always going to be functioning and stable. If you wish to work with the latest developments we suggest that you <link xl:href="mailto:martin.hurst@glasgow.ac.uk">get in touch</link> and work with us directly.</simpara>
</section>
</section>
<section xml:id="_getting_started">
<title>Getting Started</title>
<simpara>This chapter provides a brief overview of how to compile and run an example model, and plot the results using Python. For more indepth tutorials, see the later chapters.</simpara>
<section xml:id="_linux_unix_2">
<title>Linux/UNIX</title>
<section xml:id="_compiling_the_code">
<title>Compiling the code</title>
<simpara>The code can be compiled in a Linux environment from the command line, using one of the makefiles. These are contained in the <literal>driver_files</literal> subdirectory. The driver files are C++ scripts that control the initiation, running and saving of a COVE model run. In this tutorial we will use the example for running a spiral bay as used in <link xl:href="http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract">Hurst et al. (2015)</link>.</simpara>
<simpara>In a terminal, navigate to the <literal>driver_files</literal> subdirectory:</simpara>
<screen>COVE$ cd driver_files</screen>
<simpara>Compile COVE for running a spiral bay by launching the makefile:</simpara>
<screen>COVE/driver_files$ make -f spiral_bay_make.make</screen>
<simpara>This will create an executable <literal>spiral_bay.out</literal> which can be launched from the command line to run the model. First, let`s move the executable to the parent directory, and navigate to the same directory:</simpara>
<screen>COVE/driver_files$ mv spiral_bay.out ..
COVE/driver_files$ cd ..</screen>
</section>
<section xml:id="_running_the_model">
<title>Running the model</title>
<simpara>The file spiral_bay.out generated by compiling the code can be launched from the command line:</simpara>
<screen>COVE/driver_files$ ./spiral_bay.out</screen>
<simpara>Running it in this way will result in it terminating with an error, which will tell you that the program requires a number of input arguments in order to run. In the spiral bay example, the offshore wave climate is represented with three Gaussian distributions, for wave period, height and direction. Each of these is described by a mean and standard deviation, and these are fed to the model as arguments. To run the model with mean wave period of 6 seconds, standard deviation 1 second, mean wave height 1 metre, standard deviation 0.1 metre, and mean wave direction 035^o and standard deviation 25^o:</simpara>
<screen>COVE/driver_files$ ./spiral_bay.out 6 1 1. 0.1 35 25</screen>
<simpara>The model should then run for fifty years. This example evolves a crenulate-shaped bay from a straight initial coastline between two fixed headlands or sea walls. Sediment is transported out of the model domain by alongshore sediment flux and the shoreline gradually adjusts to the distribution of wave directions. The bay eventually reaches a state of equilibrium where the net alongshore flux is close to zero everywhere. The model is setup to run for 100 years, more than enough time for an equilibrium bay configuration to form.</simpara>
<simpara>While running the model will print the current model time to screen, it may also print some other messages, particularly including intersections in the coastline. The intersection analysis detects when the coastline intersects itself, such as when it erodes back behind the headland. Once this has happened the coastline is prevented from eroding any further.</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_windows_2">
<title>Windows</title>
<section xml:id="_compiling_and_running_code_blocks">
<title>Compiling and running: Code::Blocks</title>
<simpara>Since Code::Blocks is not the current development environment favoured by the COVE team, there is no Code::Blocks project file maintained in the COVE repository, and thus you will need to create one from scratch. Luckily, this process is pretty simple. Having opened Code::Blocks, from the startup click to create a new project:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images//CB_new.png"/>
</imageobject>
<textobject><phrase>CB new</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Select the "Empty project" project template then click through the empty project creation wizard. You will be asked to name the project and provide a file/folder structure (see example) and then to select a compiler (select the GNU GCC Compiler; see example). Keep the default options for "Debug" and "Release" configurations and then click <literal>Finish</literal>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images//CB_Title.png"/>
</imageobject>
<textobject><phrase>CB Title</phrase></textobject>
</mediaobject>
</informalfigure>
<warning>
<simpara>You might have got an error message about the project not being able to save at this point, you can ignore it, the project appears to be saved. If you&#8217;re not sure about this, right click on the project within the Management side panel, and click <literal>Save project</literal>.</simpara>
</warning>
<simpara>Next we need to populate the project with the required C++ files. From the top menu, click on <literal>Project &#8594; Add files&#8230;&#8203;</literal> then navigate to the COVE repository directory. Add the following list of files to your project:</simpara>
<screen>coastline.cpp, coastline.hpp
cliffline.cpp, cliffline.hpp
waveclimate.cpp, waveclimate.hpp
global_variables.hpp
./driver_files/spiral_bay_driver.cpp <co xml:id="CO1-1"/></screen>
<calloutlist>
<callout arearefs="CO1-1">
<para>Or whichever driver file you wish to work with.</para>
</callout>
</calloutlist>
<simpara>You should be able to expand the project in the Management side-bar to see these files organised by their file type (header or source).</simpara>
<simpara>To compile the code, from the top menu, click <literal>Build &#8594; Build</literal>. This will compile and link all of the code automatically and create an executable named <literal>YOUR_PROJECT_NAME.exe</literal> in the <literal>bin</literal> and <literal>debug</literal> folders of your project folder. You can then run the code from Code::Blocks by going to the top menu and clicking <literal>Build &#8594; Run</literal>. If the driver file you have chosen or created requires input arguments, these can be set by clicking <literal>Project &#8594; Set programs' arguments&#8230;&#8203;</literal>.</simpara>
</section>
</section>
<section xml:id="_plotting_the_results">
<title>Plotting the results</title>
<simpara>We make plots of the resulting coastline evolution using the python <link xl:href="http://matplotlib.org/">matplotlib</link> library. To use them you will need a python IDE such as <link xl:href="http://pythonhosted.org/spyder/">Spyder</link>. A series of plotting functions are included in the subdirectory <literal>plotting_functions</literal>. To plot the results of your spiral bay model run, open the file <literal>plot_coastline_evolution_figure.py</literal> in your favourite python IDE, and run. You should get the following figure:</simpara>
<figure>
<title>Example model output for a spiral bay showing the evolution of the bay through time from a starting condition of a straight coastline pinned by two headlands/sea walls. Model evolves to a condition of equilibrium where the coastal morphology changes little through time.</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//spiral_bay_example.png" contentwidth="500" align="center"/>
</imageobject>
<textobject><phrase>spiral bay example</phrase></textobject>
</mediaobject>
</figure>
<simpara>Additionally, below will be a link to a video of a spiral bay evolving, which will be hosted on Vimeo once I have time to work out how to do it (MDH).</simpara>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_example_model_runs">
<title>Example model runs</title>
<simpara xml:id="Examples">In this chapter we will look in detail at how the model is setup to perform a number of different example experiments. First we will look at the evolution of spiral bays from an initially straight coast line bound by sea walls or headlands, as used in <link xl:href="http://onlinelibrary.wiley.com/doi/10.1002/2015JF003704/abstract">Hurst et al. (2015)</link>. Next we will look at an example of an initially straight coastline using a periodic boundary condition subject to a mixture of low and high angle incidence offshore waves that generate hgih-angle wave instability, similar to the experiments of <link xl:href="http://onlinelibrary.wiley.com/doi/10.1029/2005JF000422/abstract">Ashton and Murray, 2006</link>. Finally we will look at an example setup for a real stretch of cliffed coastline, using a stretch of the Suffolk coastline between Lowestoft and Southwold, which includes the interesting coastal foreland Benacre Ness. Hopefully this will give you some hands on guided experience of how to set the model up and how it behaves under different wave and boundary conditions.</simpara>
<section xml:id="_driver_files">
<title>Driver files</title>
<simpara>Each example model run has a driver file. Driver files are the files we will edit in order to control and customise COVE. The driver file initialises the coast, cliffs and waves and runs the coastal simulation following the control parameters that it contains.</simpara>
<section xml:id="_structure_of_a_driver_file">
<title>Structure of a driver file</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="1">
<colspec colname="col_1" colwidth="100*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Declare Headers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Manage Input Arguments (if any)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Declare variables to control model run</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Initialise the coast, cliff and waves using variables</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Set model optional model parameters</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Setup output files</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Run Main Model Loop</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_structure_of_the_main_model_loop">
<title>Structure of the main model loop</title>
<simpara>The model loop is pretty simple really, first grab a new wave from the wave climate, second pass it to the <literal>Coastline</literal> object when calling the <literal>TransportSediment</literal> function, third print the coordinates of the new <literal>Coastline</literal> to file.</simpara>
<figure>
<title>Structure of the main model loop</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//main_loop.png" contentwidth="600" align="center"/>
</imageobject>
<textobject><phrase>main loop</phrase></textobject>
</mediaobject>
</figure>
<simpara>And in code that looks something like this:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// loop through time and evolve the coast
while (Time &lt; EndTime)
{
  //Get a new wave?
  if (Time &gt; GetWaveTime)
  {
    MyWave = WaveClimate.Get_Wave();
    GetWaveTime += WaveTimeDelta/365.;
  }

  //Evolve coast
  CoastVector.TransportSediment(TimeStep, MyWave, CliffVector);

  //update time
  Time += TimeStep/365.;

  //Write results to file
  if (Time &gt;= PrintTime)
  {
    CoastVector.WriteCoast(WriteCoastFile, Time);
    PrintTime += PrintTimeDelta;
  }
}</programlisting>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_spiral_bays">
<title>Spiral bays</title>
<simpara>Let&#8217;s look at how the model is set up to simulate the formation and evolution of crenulate-shaped bays (also known as spiral, log-spiral, zeta bays). To do so, we will open up the appropriate driver file and work through it to understand how the simulations are set up and what the model is doing.</simpara>
<section xml:id="_the_driver_file">
<title>The driver file</title>
<simpara>The driver file <literal>spiral_bay_driver.cpp</literal> can be found in the <literal>driver_files</literal> subdirectory. You can navigate to it and open in a text editor from the command line with:</simpara>
<screen>$ cd driver_files
$ gedit spiral_bay_driver.cpp &amp;</screen>
<simpara>or open it from the explorer window.</simpara>
<simpara>OK, let&#8217;s look at the driver file. There are some helpful comments that are ignored when we run the program, these start with "//" or are in blocks "/*" to "*/". At the top of the file there are some <literal>#include</literal> statements that allow the program access to some libraries we will be using, including the model`s main coastline and waveclimate objects.</simpara>
</section>
<section xml:id="_setting_up_the_wave_climate">
<title>Setting up the wave climate</title>
<simpara>The spiral_bay_driver uses a Guassian representation of the wave climate. The parameters to set up the wave climate are required as input arguments at runtime. The wave climate is defined by a <emphasis>mean</emphasis> and <emphasis>standard deviation</emphasis> value for:</simpara>
<itemizedlist>
<listitem>
<simpara>Wave period <inlineequation><alt><![CDATA[T]]></alt><mathphrase><![CDATA[T]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara>Wave height <inlineequation><alt><![CDATA[H_0]]></alt><mathphrase><![CDATA[H_0]]></mathphrase></inlineequation></simpara>
</listitem>
<listitem>
<simpara>Wave direction <inlineequation><alt><![CDATA[\theta_0]]></alt><mathphrase><![CDATA[\theta_0]]></mathphrase></inlineequation></simpara>
</listitem>
</itemizedlist>
<simpara>and hence 6 input arguments are required. The driver file runs a check at the start to make sure it has the correct number of arguments, and will terminate with an error message if not.</simpara>
<simpara>In order to initialise the wave climate the 6 input arguments first are assigned to 6 variables:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//Declare parameter for wave conditions
double OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveDirection, OffshoreStDWaveDirection, OffshoreMeanWaveHeight, OffshoreStDWaveHeight;</programlisting>
<simpara>and the corresponding input arguments are converted from character sequences to numerical values and passed to these variables.</simpara>
<simpara>The wave climate is initialised by declaring a <literal>GuassianWaveClimate</literal> object called <literal>WaveClimate</literal> and passing these variables as input arguments in the correct order.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// initialise the wave climate
GaussianWaveClimate WaveClimate = GaussianWaveClimate(OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveDirection, OffshoreStDWaveDirection, OffshoreMeanWaveHeight, OffshoreStDWaveHeight);</programlisting>
<simpara>We then also declare an individual wave object. This holds the period, height and direction of an individual wave <literal>MyWave</literal> which we later pass to the coastline object in order to drive coastal evolution. We will sample a wave from <literal>WaveClimate</literal> and pass it to <literal>MyWave</literal></simpara>
<programlisting language="c++" linenumbering="unnumbered">// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from thewave climate object
MyWave = WaveClimate.Get_Wave();</programlisting>
</section>
<section xml:id="_model_run_control_parameters">
<title>Model run control parameters</title>
<simpara>Various parameters are required to control the length of the model run (in years), how often the coastline position is output to file (in years), how often to sample a new wave from the wave climate object (days), and how big the model timestep should be (days). We suggest leaving these as they are for now, but as you start customising model setup you may need to adjust them.</simpara>
<programlisting language="c++" linenumbering="unnumbered">//declare time control paramters
int EndTime = 50.; // End time (years)
double Time = 0.; // Start Time (years)
double PrintTimeDelta = 36.5/365.; // how often to print coastline (years)
double PrintTime = PrintTimeDelta; // Print time (years)

double WaveTimeDelta = 0.1; // Frequency at which to sample new waves (days)
double GetWaveTime = 0.0; // Time to get a new wave (days)
double TimeStep = 0.05; // Time step (days)</programlisting>
</section>
<section xml:id="_initialise_the_model">
<title>Initialise the model</title>
<simpara>The spiral bay model is initialised as a straight coast with fixed boundaries at each end of the coast line. In order to generate the coastline object, we need to prescribe some attributes that dictate the properties of the generated coast, which we will pass to the new Coastline object when we declare it.</simpara>
<programlisting language="c++" linenumbering="unnumbered">//initialise coast as straight line with low amp noise
int MeanNodeSpacing = 50; // in metres
double CoastLength = 2000; // in metres
double Trend = 140.; // in degrees

//boundary conditions are fixed
int StartBoundary = 2;
int EndBoundary = 2;</programlisting>
<itemizedlist>
<listitem>
<simpara><literal>MeanNodeSpacing</literal> sets approximately how widely spaced the Coastline cells will be. It is a mean value, because as the model evolves, nodes might get closer together or further apart, and nodes will be dynamically added or destroyed accordingly in order to maintain this average.</simpara>
</listitem>
<listitem>
<simpara><literal>CoastLength</literal> is the length of the coastline between the fixed (or otherwise) end nodes.</simpara>
</listitem>
<listitem>
<simpara><literal>Trend</literal> is the orientation (azimuth) that the straight coastline should extend in.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The sea is always on the left side of the vector, so imagine you are standing at node '[0]' looking down the vector. If the <literal>Trend</literal> is 140<superscript>o</superscript> then the sea is to the nort-east and the land to the south-west.</simpara>
</note>
<simpara>OK now that we have these variables in place we can go ahead and declare the Coastline object.</simpara>
<programlisting language="c++" linenumbering="unnumbered">//initialise the coastline as a straight line
Coastline CoastVector = Coastline(MeanNodeSpacing, CoastLength, Trend, StartBoundary,
	EndBoundary);

//Initialise an empty/dummy cliffline object here
Cliffline CliffVector;</programlisting>
<simpara>We declare a <literal>Coastline</literal> object whech we have called <literal>CoastVector</literal>, this is our coast, and all of its morphological properties are stored internally within the object. We provide the input arguments to the call in the order listed.</simpara>
<simpara>Note there is also a call to declare a <literal>Cliffline</literal> object called <literal>CliffVector</literal>. It has no input arguments and therefore generates an empty <literal>Cliffline</literal> object (i.e. there is no actual cliff line inside it). Our spiral bay experiments don`t require a cliffline object so that is OK, but this declaration is required to keep the model happy (it needs to be able to look at a cliff to know it doesn`t really exist, it`s a dummy cliff). Don`t worry about this for now, this will generate a warning when we come to run the model but we are OK to ignore it.</simpara>
<simpara>Finally, for our spiral bay runs, we want to allow some simple rules for the refreaction and diffraction of waves behind coastal obstructions to be operating. To do this we need to set a flag within the <literal>Coastline</literal> object, 1 = on, 0 = off.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Allow refraction/diffraction rules
int RefDiffFlag = 1;
CoastVector.SetRefDiffFlag(RefDiffFlag);</programlisting>
<simpara>Finally, before we run the main model loop, we&#8217;ll write the initial conditions to file:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// loop through time and evolve the coast
CoastVector.WriteCoast(WriteCoastFile, Time);</programlisting>
</section>
<section xml:id="_main_model_loop">
<title>Main model loop</title>
<simpara>We&#8217;re all set up and ready to go! The model loop is pretty simple really, first grab a new wave from the wave climate, second pass it to the <literal>Coastline</literal> object when calling the <literal>TransportSediment</literal> function, third print the coordinates of the <literal>Coastline</literal> to file.</simpara>
<simpara>The model evolves until the <literal>Time</literal> exceeds the prescribed <literal>EndTime</literal>:</simpara>
<programlisting language="c++" linenumbering="unnumbered">while (Time &lt; EndTime)
{
	...</programlisting>
<simpara>We grab a new wave from the wave climate if it&#8217;s time (<literal>GetWaveTime</literal> depends on <literal>WaveTimeDelta</literal> which sets how often we get a new wave):</simpara>
<programlisting language="c++" linenumbering="unnumbered">//Get a new wave?
if (Time &gt; GetWaveTime)
{
	MyWave = WaveClimate.Get_Wave();
	GetWaveTime += WaveTimeDelta/365.;
}</programlisting>
<simpara>Notice that <literal>GetWaveTime</literal> is in years, but <literal>WaveTimeDelta</literal> is in days, so we divide through by 365 to convert.</simpara>
<simpara>Now we evolve the coast by calling the <literal>Coastline</literal> function <literal>TransportSediment</literal>. This requires three input arguments, <literal>TimeStep</literal> is the length of time that sediment is transported over, we also give it the wave <literal>MyWave</literal>, and finally the dummy Cliffline object <literal>CliffVector</literal>:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//Evolve coast
CoastVector.TransportSediment(TimeStep, MyWave, CliffVector);</programlisting>
<simpara>A whole lot of things happen inside this function (see a later section of this documentation that is yet to be written). The shoreline geometry is recalculated at each timestep. The wave is transformed from offshore to wave breaking conditions following linear wave theory, and any wave shadowing and refraction/diffraction are calculated. Alongshore sediment transport for each cell is calculated and the change in the volume of sediment in each cell calculated from the divergence of alongshore flux. The volume change is inverted for a change in the position of the coast and the position of each node is updated accordingly. The coastal geometry is updated for the next timestep.</simpara>
<simpara>There is a crude attempt written in here to allow adaptive timestepping. This hasn&#8217;t fully been tested yet, and usually if it&#8217;s called it&#8217;s because there is a bug in the model not actually associated with the adaptive timestep. If you run into this problem please <link xl:href="mailto:martin.hurst@glasgow.ac.uk">email me</link>.</simpara>
<simpara>Finally, the model prints the updated <emphasis>X</emphasis> and <emphasis>Y</emphasis> coordinates to an output file. See Writing Results to File for details of the resulting file format.</simpara>
</section>
<section xml:id="_compile_and_run">
<title>Compile and Run</title>
<simpara>Compile COVE for running a spiral bay by launching the makefile:</simpara>
<screen>COVE/driver_files$ make -f spiral_bay_make.make</screen>
<simpara>The file spiral_bay.out generated by compiling the code can be launched from the command line. The program takes the wave climate parameters as inputs <inlineequation><alt><![CDATA[T_{mean}]]></alt><mathphrase><![CDATA[T_{mean}]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[T_{std}]]></alt><mathphrase><![CDATA[T_{std}]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[H_{mean}]]></alt><mathphrase><![CDATA[H_{mean}]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[H_{std}]]></alt><mathphrase><![CDATA[H_{std}]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[\theta_{mean}]]></alt><mathphrase><![CDATA[\theta_{mean}]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[\theta_{std}]]></alt><mathphrase><![CDATA[\theta_{std}]]></mathphrase></inlineequation>:</simpara>
<screen>COVE/driver_files$ ./spiral_bay.out 6 1 1. 0.1 35 25</screen>
<simpara>The model should then run for fifty years. This example evolves a crenulate-shaped bay from a straight initial coastline between two fixed headlands or sea walls. Sediment is transported out of the model domain by alongshore sediment flux and the shoreline gradually adjusts to the distribution of wave directions. The bay eventually reaches a state of equilibrium where the net alongshore flux is close to zero everywhere. The model is setup to run for fifty years, more than enough time for an equilibrium bay configuration to form.</simpara>
<simpara>While running the model will print the current model time to screen, it may also print some other messages, particularly including intersections in the coastline. The intersection analysis detects when the coastline intersects itself, such as when it erodes back behind the headland. Once this has happened the coastline is prevented from eroding any further.</simpara>
</section>
<section xml:id="_plotting_the_results_2">
<title>Plotting the results</title>
<simpara>A series of plotting functions are included in the subdirectory <literal>plotting_functions</literal>. To plot the results of your spiral bay model run, open the file <literal>plot_coastline_evolution_figure.py</literal> in your favourite python IDE, and run. You should get the following figure:</simpara>
<figure>
<title>Example model output for a spiral bay showing the evolution of the bay through time from a starting condition of a straight coastline pinned by two headlands/sea walls. Model evolves to a condition of equilibrium where the coastal morphology changes little through time.</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//spiral_bay_example.png" contentwidth="500" align="center"/>
</imageobject>
<textobject><phrase>spiral bay example</phrase></textobject>
</mediaobject>
</figure>
<sidebar>
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Try varying the dominant wave direction and the spread of wave directions and see what shape of bay emerges.</simpara>
</listitem>
<listitem>
<simpara>Try varying the wave height and see whether this affects how quickly steady-state is achieved.</simpara>
</listitem>
<listitem>
<simpara>Try running with wave directions from the south-east and see if you can create a mirror image of the original experiment.</simpara>
</listitem>
</itemizedlist>
</sidebar>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_cusps_capes_and_spits">
<title>Cusps, Capes and Spits</title>
<simpara>In this example, we will setup a model that simulates the formation of cusps, capes and spits, similar to the experiments of Ashton and Murray (2006). The type of coastal landform that the model produces depends on the nature of the wave climate used. Ashton and Murray (2006) developed a 4-bin approach to characterising offshore wave climates using two paramters; the proportion of waves that approach from high angle (<emphasis>U</emphasis>) and the proportion of waves that approach from the "left" (<emphasis>A</emphasis>), that is to say, the proportion of waves that would drive alongshore sediment transport <emphasis>down</emphasis> coast on a straight coastline (see section X for more info on this wave climate).</simpara>
<section xml:id="_the_driver_file_2">
<title>The driver file</title>
<simpara>The appropriate driver file is <literal>straight_periodic_driver.cpp</literal> and can be found in the <literal>driver_files</literal> subdirectory. You can navigate to it and open in a text editor from the command line with:</simpara>
<screen>$ cd driver_files
$ gedit straight_periodic_driver.cpp &amp;</screen>
<simpara>or open it from the explorer window.</simpara>
<simpara>The driver file has been commented up helpfully to explain what is going on throughout. The driver file structure follows that laid out in section 5.1 (add link). We will assume you are already familiar with the <literal>spiral_bay_driver.cpp</literal> example.</simpara>
</section>
<section xml:id="_setting_up_the_wave_climate_2">
<title>Setting up the wave climate</title>
<simpara>Out straight, periodic boundary model run uses a UA wave climate, and hence 2 input arguments are required:</simpara>
<itemizedlist>
<listitem>
<simpara>Wave direction highness (<emphasis>U</emphasis>)</simpara>
</listitem>
<listitem>
<simpara>Wave direction asymmetry (<emphasis>A</emphasis>)</simpara>
</listitem>
</itemizedlist>
<simpara>Other wave parameters (period and height) are assigned explicitly within the driver file. The wave climate variables are assigned:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//Initialise real wave climate and temporary wave to pass
double U = atof(argv[1]);
double A = atof(argv[2]);
double OffshoreMeanWavePeriod = 6.;
double OffshoreStDWavePeriod = 1.;
double OffshoreMeanWaveHeight = 1.;
double OffshoreStDWaveHeight = 1.;</programlisting>
<simpara>and these provide the corresponding input arguments for initialising the <literal>UAWaveClimate</literal> object. The wave climate is initialised by declaring a <literal>UAWaveClimate</literal> object called <literal>WaveClimate</literal> and passing it these variables as input arguments:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//initialise wave climate
UAWaveClimate WaveClimate = UAWaveClimate(U, A, Trend, OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveHeight, OffshoreStDWaveHeight);</programlisting>
<simpara>We then also declare an individual wave object. This holds the period, height and direction of an individual wave <literal>MyWave</literal> which we later pass to the coastline object in order to drive coastal evolution. We will sample a wave from <literal>WaveClimate</literal> and pass it to <literal>MyWave</literal>:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from thewave climate object
MyWave = WaveClimate.Get_Wave();</programlisting>
</section>
<section xml:id="_model_run_control_parameters_2">
<title>Model run control parameters</title>
<simpara>Similar to the spiral bay example, we need to declare parameters to control the length of the model run, how often we save results to file and when to sample new waves from the wave climate.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// DECLARATIONS
// These are the parameters that control the model run
//declare time control paramters
int EndTime = 100.; // End time (years)
double Time = 0.; // Start Time (years)
double PrintTimeDelta = 36.5/365.; // how often to print coastline (years)
double PrintTime = PrintTimeDelta; // Print time (years)

double WaveTimeDelta = 0.2; // Frequency at which to sample new waves (days)
double GetWaveTime = 0.; // Time to get a new wave (days)
double TimeStep = 0.2; // Time step (days)
double MaxTimeStep = 0.2; // Maximum timestep (days)</programlisting>
</section>
<section xml:id="_initialise_the_model_2">
<title>Initialise the model</title>
<simpara>There are two possible boundary types in COVE, fixed or periodic (at the moment). We want boundary conditions that are periodic, so sediment passed out of one end of the model is provided to the other. This means the end two nodes are geometric copies of each other and always experience the same amount of flux and change. We use an integer flag to specify boundary conditions, where 1 = periodic and 2 = fixed:</simpara>
<programlisting language="c++" linenumbering="unnumbered">int StartBoundary = 1;
int EndBoundary = 1;</programlisting>
<simpara>For periodic boundary condition runs initialise coast as straight line with a node spacing of 100 m and orientate the coast nort-south.</simpara>
<programlisting language="c++" linenumbering="unnumbered">double Trend = 180.; // aximuth in degrees
int NodeSpacing = 100; // in metres
double CoastLength = 20000; // in metres</programlisting>
<simpara>So now we can initialise the coastline as a straight line. With this call, we are creating a Coastline object which we will call CoastVector. To do this we need to provide this initialisation member function with 5 arguments so it can setup the coastline as we want it. We also create a Cliffline object, but because we do not assign it (there is no = sign), it will be completely empty (i.e. there is no cliff). When COVE checks to see whether there is a cliff to work with, it needs to see an empty cliff object to know that no cliff exists. I&#8217;d like to find a way to put thi "under the hood" but this will have to do for now.</simpara>
<programlisting language="c++" linenumbering="unnumbered">//initialise the coastline as a straight line
Coastline CoastVector = Coastline(NodeSpacing, CoastLength, Trend, StartBoundary, EndBoundary);

// Initialise an empty/dummy cliffline object here.
Cliffline CliffVector;</programlisting>
<simpara>The periodic coast expreiments do not require a <literal>Cliffline</literal> object but the declaration is required to keep the model happy. This will generate a warning when we initialise the model but we are OK to ignore it.</simpara>
</section>
<section xml:id="_set_other_model_parameters">
<title>Set other model parameters</title>
<simpara>Next we need to set some other model parameters required to describe the shoreface and the style of sediment transport. There are a series of public <literal>set_</literal> member functions that allow us to do this. Each of these have default values, so if you don&#8217;t set them the model will jsut use the defaults. The values we&#8217;re going to set here are the default values, just for illustrative purposes. They are</simpara>
<itemizedlist>
<listitem>
<simpara>The Sediment flux flag (integer for which flux equation to use)</simpara>
</listitem>
<listitem>
<simpara>The refraction/diffraction flag (as set in the spiral bay example)</simpara>
</listitem>
<listitem>
<simpara>The shoreface depth (<inlineequation><alt><![CDATA[D_{sf}]]></alt><mathphrase><![CDATA[D_{sf}]]></mathphrase></inlineequation>; see Figure X)</simpara>
</listitem>
<listitem>
<simpara>The shoreface slope (<inlineequation><alt><![CDATA[\beta]]></alt><mathphrase><![CDATA[\beta]]></mathphrase></inlineequation>; see Figure X)</simpara>
</listitem>
</itemizedlist>
<simpara>First we will declare some temporary variables for these, and then call the functions to set them within the model:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Declare variables
int CERCFlag = 1;
int RefDiffFlag = 0;
double ShorefaceDepth = 10.;
double ShorefaceSlope = 0.02;

// Call the set public member functions to control these parameters
CoastVector.SetRefDiffFlag(RefDiffFlag);
CoastVector.SetFluxType(CERCFlag);
CoastVector.SetShorefaceDepth(ShorefaceDepth);
CoastVector.SetShorefaceSlope(ShorefaceSlope);</programlisting>
</section>
<section xml:id="_set_up_output_file">
<title>Set up output file</title>
<simpara>We will automatically create an output file name based on the wave parameters provided as input arguments, and write the initial conditions to file uing the <literal>WriteCoast</literal> member function (see Writing Results to File section for more details).</simpara>
<programlisting language="c++" linenumbering="unnumbered">//setup output file for writing results based on wave climate params
string arg1 = argv[1];
string arg2 = argv[2];
string underscore = "_";
string WriteCoastFile = "COVE" + underscore + arg1 + underscore + arg2 + ".xy";

// Write initial coast to file
CoastVector.WriteCoast(WriteCoastFile, Time);</programlisting>
</section>
<section xml:id="_main_model_loop_2">
<title>Main model loop</title>
<simpara>This follows the same structure as outlined in section X.</simpara>
</section>
<section xml:id="_compile_and_run_2">
<title>Compile and Run</title>
<simpara>Compile COVE for running the straight, periodic coast example by launching the makefile:</simpara>
<screen>COVE/driver_files$ make -f straight_periodic_make.make</screen>
<simpara>This should create an executable file called <literal>Straight_Periodic.out</literal> which can be launched from the command line. The program requires two input arguments, <emphasis>U</emphasis> and <emphasis>A</emphasis>:</simpara>
<screen>COVE/driver_files$ ./Straight_Periodic.out 0.55 0.7</screen>
<simpara>This will run the model with 55% of waves coming from high angle, and 70% of waves coming from the north-east quadrant. This should result in the formation of sand waves that migrate down the coast (untested!). We should also be able to observe waves that migrate off the bottom of the model domain reappearing at the top.</simpara>
<simpara>While running the model will print the current model time to screen, and may also print some other messages recording unusual model behaviour!</simpara>
</section>
<section xml:id="_plotting_the_results_3">
<title>Plotting the results</title>
<simpara>To plot the results of this run, we are going to create an animation! Open the file <literal>filename_here.py</literal> in your favourite python IDE, and run. You should get a series of figures whose file names are numbered sequentially and each looks a bit like this:</simpara>
<figure>
<title>Example model output from periodic boundary run.</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//benacre_output.png" contentwidth="300" align="center"/>
</imageobject>
<textobject><phrase>benacre output</phrase></textobject>
</mediaobject>
</figure>
<simpara>The python script creates a file called filelist.txt which contains a list of all the output filenames. These frames can then be stitched together to create a video of the coastline evolving using <link xl:href="https://en.wikipedia.org/wiki/MEncoder">Mencoder</link>, a command line tool that is part of <link xl:href="http://www.mplayerhq.hu/design7/news.html">MPlayer</link> that allows you to encode video files (Linux only). Thus once you have run the python script, you can run the following command to stich the output together into a nice video:</simpara>
<screen>$ mencoder mf://@filelist.txt -mf w=300:h=600:fps=25:type=png -ovc lavc -lavcopts vcodec=mpeg4:mbd=2:trell -oac copy -o video.avi</screen>
<simpara>Once you&#8217;ve made the video, you can delete all the individual png frame files to keep things tidy:</simpara>
<screen>$ rm *.png</screen>
<sidebar>
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Try varying the <emphasis>U</emphasis> and <emphasis>A</emphasis> wave climate to see what sort of coastal landforms you can get to emerge. Note that if you try and create some spits there is currently no way for them to migrate across the periodic boundary condition! Ashton and Murray (2006) observed the following landforms developed under varying <emphasis>U</emphasis> and <emphasis>A</emphasis> conditions:</simpara>
</listitem>
</itemizedlist>
</sidebar>
<figure>
<title>Types of landforms that emerge in the CEM depending on <emphasis>U</emphasis> and <emphasis>A</emphasis> (from Ashton and Murray, 2006).</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//UA_phasespace.png" contentwidth="500" align="center"/>
</imageobject>
<textobject><phrase>UA phasespace</phrase></textobject>
</mediaobject>
</figure>
<simpara><?asciidoc-pagebreak?></simpara>
</section>
</section>
<section xml:id="_real_cliffed_coast">
<title>Real cliffed coast</title>
<simpara>Let&#8217;s look at how to set the model up to run on a real stretch of cliffed coastline. The example we are going to look at is from the coast of Suffolk between Lowestoft and Southwold (see Figure 5).</simpara>
<simpara>Insert figure here of study site.</simpara>
<simpara>This coastline experiences a bimodal wave climate, with waves coming out of the North Sea to the north east, and through the English Channel from the South.</simpara>
<simpara>We are interested in this stretch of coastline because at Kessingland there is a large coastal foreland called Benacre Ness that is migrating northward along the coast. It is called Benacre Ness because it used to sit in front of the Benacre estate, but has migrated northward and now stretches across the frontage of Kessingland. It has been estimated to extend northward at rates of 20-50 m y<superscript>-1</superscript>, despite the locally established view that alongshore sediment transport is directed from north to south.</simpara>
<section xml:id="_the_driver_file_3">
<title>The driver file</title>
<simpara>The driver file <literal>benacre_driver.cpp</literal> can be found in the <literal>driver_files</literal> subdirectory. Hopefully the comments in the code will be helpful as you look through. These are ignored when the program is run. At the top of the file there are some <literal>#include</literal> statements that allow the program access to some libraries we will be using, including the model`s main coastline, cliffline and waveclimate objects.</simpara>
</section>
<section xml:id="_model_run_control_parameters_3">
<title>Model run control parameters</title>
<simpara>Various parameters are required to control the length of the model run (in years), how often the coastline and cliffline positions are output to file (in years), how often to sample a new wave from the wave climate object (days), and how big the model timestep should be (days). We suggest leaving these as they are for now, but as you start customising model setup you may need to adjust them.</simpara>
<programlisting language="c++" linenumbering="unnumbered">	//declare time control paramters
	int EndTime = 50.;	// End time (years)
	double Time = 0.;	// Start Time (years)
	double PrintTimeDelta = 36.5/365.;	// how often to print coastline (years)
	double PrintTime = PrintTimeDelta;	// Print time (years)

	double WaveTimeDelta = 0.2;	// Frequency at which to sample new waves (days)
	double GetWaveTime = 0.;	// Time to get a new wave (days)
	double TimeStep = 0.2;	// Time step (days)
	double MaxTimeStep = 0.2;	// Maximum timestep (days)</programlisting>
</section>
<section xml:id="_input_files">
<title>Input files</title>
<simpara>Using a real coastline, the model will require three input files in order to initialise the coast. A coastline <emphasis>x-y</emphasis> file, a cliffline <emphasis>x-y</emphasis> file and cliff type file. These are available in the <literal>example_inputs</literal> subdirectory of the repository. From the <literal>driver_file</literal> directory copy these across at the command line ready for running the model:</simpara>
<screen>/COVE/driver_files/$ cp ../example_inputs/* .</screen>
<simpara>These files have been declared in the driver file:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// initialise the coastline and cliffline objects from file
// first declare the filenames
string CliffInFile = "Benacre_Cliffline_Points.xy";
string CoastInFile = "Benacre_Coastline_Points.xy";
string FixedFileName = "Benacre_Fixed_Cliffs.data";</programlisting>
<simpara>The coastline and cliffline <emphasis>*.xy</emphasis> files have the same format as the model output, consisting of a header line with two space-separated integers representing the start and end boundary conditions, followed by lines containing the <emphasis>x</emphasis> and <emphasis>y</emphasis> coordinates of the coastline, preceded by the time (see "Read a coast from file" in the "under the hood" section).</simpara>
<screen>StartBoundary | EndBoundary
Time | X[0] | X[1] | X[2] =====&gt; X[NoNodes]
Time | Y[0] | Y[1] | Y[2] =====&gt; Y[NoNodes]</screen>
<simpara>The order that your <emphasis>x</emphasis> and <emphasis>y</emphasis> coordinates come in is very important. The model <emphasis role="strong">ALWAYS</emphasis> assumes that the sea is on the left side as it works its way down the coastline or cliffline vector. To be sure you get this correct, imagine you are standing at the first node on your coastline, looking towards the second node. The sea will be on the left of the line, and the land on the right (see Figure 5). If this is backwards, you will get some very strange behaviour, because the model will ignore alot of waves (since they are coming from the land) and beach widths will be negative. If your first attempt at modelling a stretch of coastline blows up straight away, this is the first thing to check. We should probably write some error checking into the beach width calculator to flag negative values and warn you. This will get added in later.</simpara>
<figure>
<title>Google Earth image of the coastline of Suffolk between Lowestoft and Southwold showing the beginning and end of the coastline vector the correct way around.</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//coastline_orientation.png" contentwidth="500" align="center"/>
</imageobject>
<textobject><phrase>coastline orientation</phrase></textobject>
</mediaobject>
</figure>
<simpara>The third file required is a cliff type file. This tells the model whether a cliff node can erode or is fixed (this can later be expanded to include different types of geology). Currently a value of 1 represents a fixed coast (e.g. defended by sea wall/revetment) and a value of 0 is a normal erodible cliff. The file format is a header line followed by two columns, one for the node index (<literal>i=0</literal> to <literal>i=NoNodes-1</literal>) and the second for the cliff type integer.</simpara>
<screen>Index Type
0 1
1 0
2 0
...
NoNode-1 1</screen>
</section>
<section xml:id="_wave_climate">
<title>Wave climate</title>
<simpara>Wave data from the Southwold wave buoy shows that our example coast is hit by a bimodal wave climate. The wave buoy is in 25 m water depth and suggests high angle waves impinging toward the coast, which if fed directly to the model results in high angle wave instability that is not observed on this stretch of coastline. A legacy data set from a previously deployed AWAC wave buoy shows that these dominant wave modes get rotated to lower angle of incidence by the time they reach the shoreface, so for these example experiments, we have chosen a similar lower angle, bimodal wave climate.</simpara>
<simpara>Our bimodal wave climate consists of two Gaussian wave climates as used in the spiral bay experiments. The parameters for these have been declared in the driver file diectly rather than being passed as input arguments.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Bimodal wave climate
//Wave climate 1
double OffshoreMeanWaveDirection1 = 45.;
double OffshoreStDWaveDirection1 = 20.;
double OffshoreMeanWavePeriod1 = 6.;
double OffshoreStDWavePeriod1 = 2.;
double OffshoreMeanWaveHeight1 = 0.8;
double OffshoreStDWaveHeight1 = 0.2;
GaussianWaveClimate WaveClimate1(OffshoreMeanWavePeriod1,OffshoreStDWavePeriod1,OffshoreMeanWaveDirection1,OffshoreStDWaveDirection1,OffshoreMeanWaveHeight1, OffshoreStDWaveHeight1);

//Wave climate 2
double OffshoreMeanWaveDirection2 = 140.;
double OffshoreStDWaveDirection2 = 20.;
double OffshoreMeanWavePeriod2 = 5.;
double OffshoreStDWavePeriod2 = 1.;
double OffshoreMeanWaveHeight2 = 1.1;
double OffshoreStDWaveHeight2 = 0.2;
GaussianWaveClimate WaveClimate2(OffshoreMeanWavePeriod2,OffshoreStDWavePeriod2,OffshoreMeanWaveDirection2,OffshoreStDWaveDirection2,OffshoreMeanWaveHeight2, OffshoreStDWaveHeight2);</programlisting>
<simpara>So we have two wave climate objects, <literal>WaveClimate1</literal> and <literal>WaveClimate2</literal>. As before we also need to declare an individual wave object:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//declare wave
Wave MyWave = Wave();
MyWave = WaveClimate1.Get_Wave();</programlisting>
<simpara>In the main model loop, we will use a random number generate to select which wave climate to grab a wave from at random, and assign it to <literal>MyWave</literal> ready to evolve the coast.</simpara>
</section>
<section xml:id="_initialisation">
<title>Initialisation</title>
<simpara>We initialise both the coastline and the cliffline objects by pointing them to the respective input files as detailed in the previous subsection. We then provide an extra call to the CliffVector object to tell it to read whether the cliff is fixed or erodible:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Read the coastline and cliffline data from files
double StartTime = 0;
Cliffline CliffVector = Cliffline(CliffInFile, StartTime);
Coastline CoastVector = Coastline(CoastInFile, StartTime);

// Load data on cliff type (fixed vs erodible)
CliffVector.ReadCliffType(FixedFileName);</programlisting>
<simpara>Then we declare a couple more file names where we will write the output files for both the cliffline and the coastline object:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//declare output file names
string WriteCoastFile = "CliffedCoast_Coastline.xy";
string WriteCliffFile = "CliffedCoast_Cliffline.xy";</programlisting>
<simpara>There are a few other things we need to set up for this run; how fast the cliffs can erode, how high the cliffs are, what the critical beach width is that maximises cliff erosion, and how much cliff material gets lost offshore when the cliff erodes.</simpara>
<simpara>First, we will setup the maximum retreat rate. This is the fastest retreat rate the cliffs can manage, and can be informed or calibrated by historical observations of cliff retreat. For our section of the Suffolk coast, we will set this to 5 m yr<superscript>-1</superscript>, guided by <link xl:href="http://www.sciencedirect.com/science/article/pii/S0169555X10003533">Brooks and Spencer (2010)</link>.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Set Maximum Retreat Rate (m/yr)
// This is E0 for the Valvo et al. (2006) or Limber and Murray (2011) models of cliff erosion
double RetreatRate = 5.;
CliffVector.SetMaxRetreatRate(RetreatRate);</programlisting>
<simpara>Second, we will set the cliff height. At the moment this is spatially and temporally continuous, but functionality can be added later to extract this value from a DEM as the model evolves.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Set Cliff Height (m)
// Fixed for now, but could in the future grab this from a DEM
double CliffHeight = 10.;
CliffVector.SetCliffHeight(CliffHeight);</programlisting>
<simpara>Third, we set the critical beach width. This is the beach width at which the maximum rate of cliff retreat occurs. For wider beaches, the rate of cliff retreat declines exponentially. We will set this to 5 m, suggesting that a 5 m wide beac provides the optimal balance between protecting the cliff and providing abrasive tools such that cliff erosion is maximised.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Set critical beach width (m)
// The beach width that maximises the rate of cliff retreat E0
double CriticalBeachWidth = 5.;
CliffVector.SetCriticalWidth(CriticalBeachWidth);</programlisting>
<simpara>Fourth, we set the style of cliff retreat. <literal>ErosionType = 1</literal> if using a <link xl:href="http://onlinelibrary.wiley.com/doi/10.1029/2005JF000340/full">Valvo et al. (2006)</link> type of relationship between beach width and cliff retreat (this is effectively the same as setting <literal>CriticalBeachWidth = 0</literal> and thus redundant). 'ErosionType = 2' uses the <link xl:href="http://geology.gsapubs.org/content/39/12/1147.short">Limber and Murray (2011)</link> relationship between beach width and cliff retreat where cliff retreat rate peaks at <literal>CriticalBeachWidth</literal>.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// For Valvo Style Cliff Retreat ErosionType = 1,
// for Limber and Murray ErosionType = 2
int ErosionType = 1;</programlisting>
<simpara>Fifth, we set the proportion of cliff material assumed to be lost to the sea:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Set lost cliff fraction
// The proportion of cliff material that is lost offshore by suspension
double LostFraction = 0.2;
CliffVector.SetLostFraction(LostFraction);</programlisting>
<simpara>And finally, since the Suffolk beaches are mixed sand/shingle, we tell the coastline object to use an alongshore flux equation that has been modified to better reflect gravel transport rates:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Set lost cliff fraction
// The proportion of cliff material that is lost offshore by suspension
double LostFraction = 0.2;
CliffVector.SetLostFraction(LostFraction);</programlisting>
</section>
<section xml:id="_main_model_loop_3">
<title>Main model loop</title>
<simpara>Good to go! The model loop is pretty simple really, first grab a new wave at random from one of the two wave climates, second pass it to the <literal>Coastline</literal> object when calling the <literal>TransportSediment</literal> function, third call the <literal>Cliffline</literal> object&#8217;s <literal>ErodeCliff</literal> function, and finally print the coordinates of both the <literal>Coastline</literal> and <literal>Cliffline</literal> to file.</simpara>
<simpara>The model evolves until the <literal>Time</literal> exceeds the prescribed <literal>EndTime</literal>:</simpara>
<programlisting language="c++" linenumbering="unnumbered">while (Time &lt; EndTime)
{
	...</programlisting>
<simpara>We grab a new wave from the wave climate if it&#8217;s time (<literal>GetWaveTime</literal> depends on <literal>WaveTimeDelta</literal> which sets how often we get a new wave):</simpara>
<programlisting language="c++" linenumbering="unnumbered">//Get a new wave?
if (Time &gt; GetWaveTime)
{
	// Use a random sampler to chose between wave climates
	rand1 = (double)rand()/RAND_MAX;
	if (rand1 &lt; 0.5) MyWave = WaveClimate1.Get_Wave();
	else MyWave = WaveClimate2.Get_Wave();
	GetWaveTime += WaveTimeDelta/365.;
}</programlisting>
<simpara><literal>rand1</literal> selects a random number between 0 and 1. When <literal>rand1 &lt; 0.5</literal> we use <literal>WaveClimate1</literal> and otherwise we use <literal>WaveClimate2</literal> so we should be sampling equally from both wave climates. Notice that <literal>GetWaveTime</literal> is in years, but <literal>WaveTimeDelta</literal> is in days, so we divide through by 365 to convert.</simpara>
<simpara>Now we evolve the coast by calling the <literal>Coastline</literal> function <literal>TransportSediment</literal>, followed by the <literal>Cliffline</literal> function <literal>ErodeCliff</literal>. Each requires three input arguments. For the <literal>Coastline.TransportSediment</literal> call, <literal>TimeStep</literal> is the length of time that sediment is transported over, we also give it the wave <literal>MyWave</literal>, and finally the <literal>Cliffline</literal> object <literal>CliffVector</literal> so that it can only erode beach material that fronts the cliff. For the <literal>Cliffline.ErodeCliff</literal> call, we pass <literal>TimeStep</literal> again, the <literal>Coastline</literal> object, and the type of erosion law <literal>ErosionType</literal>.</simpara>
<programlisting language="c++" linenumbering="unnumbered">//Evolve coast
CoastVector.TransportSediment(TimeStep, MyWave, CliffVector);
CliffVector.ErodeCliff(TimeStep, CoastVector, ErosionType);</programlisting>
<simpara>A whole lot of things happen inside these functions (see a later section of this documentation that is yet to be written). Coastline and Cliffline geometry is recalculated at each timestep. The wave is transformed from offshore to wave breaking conditions following linear wave theory, and any wave shadowing and refraction/diffraction are calculated. Alongshore sediment transport for each cell is calculated and the change in the volume of sediment in each cell calculated from the divergence of alongshore flux, checking with the Cliffline position that sediment is available for transport. The volume change is inverted for a change in the position of the coast and the position of each node is updated accordingly. The coastal geometry is updated for the next timestep. The width of the beach is calculated by comparing the Coastline and Cliffline objects and this determines the amount of cliff retreat. The Cliffline position is updated and the amount of volume lost is supplied to the adjacent beach, minus the amount lost to the sea.</simpara>
<simpara>Finally, the model prints the updated <emphasis>X</emphasis> and <emphasis>Y</emphasis> coordinates to two output files. See Writing Results to File for details of the resulting file format.</simpara>
</section>
<section xml:id="_compile_and_run_3">
<title>Compile and run</title>
<simpara>Compile COVE for running the Suffolk example by launching the makefile:</simpara>
<screen>COVE/driver_files$ make -f benacre_make.make</screen>
<simpara>The file benacre.out generated by compiling the code can be launched from the command line without any input arguments :</simpara>
<screen>COVE/driver_files$ ./benacre.out</screen>
<simpara>The model should then run for fifty years. This example evolves the Suffolk coast such that the cuspate foreland Benacre Ness migrates northward up the coast at rates in keeping with historical observations. While running the model will print the current model time to screen.</simpara>
</section>
<section xml:id="_plotting_the_results_4">
<title>Plotting the results</title>
<simpara>A series of plotting functions are included in the subdirectory <literal>plotting_functions</literal>. To plot the results of your Suffolk model run, open the file <literal>benacre_evolution_animation.py</literal> in your favourite python IDE, and run. You should get a series of figures whose file names are numbered sequentially and each looks a bit like this:</simpara>
<figure>
<title>Example model output from the Suffolk coast showing the stretch of coastline between Lowestoft and Southwold.</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//benacre_output.png" contentwidth="300" align="center"/>
</imageobject>
<textobject><phrase>benacre output</phrase></textobject>
</mediaobject>
</figure>
<simpara>The python script creates a file called filelist.txt which contains a list of all the output filenames. These frames can then be stitched together to create a video of the coastline evolving using <link xl:href="https://en.wikipedia.org/wiki/MEncoder">Mencoder</link>, a command line tool that is part of <link xl:href="http://www.mplayerhq.hu/design7/news.html">MPlayer</link> that allows you to encode video files. Thus once you have run the python script, you can run the following command to stich the output together into a nice video:</simpara>
<screen>$ mencoder mf://@filelist.txt -mf w=300:h=600:fps=25:type=png -ovc lavc -lavcopts vcodec=mpeg4:mbd=2:trell -oac copy -o video.avi</screen>
<simpara>Once you&#8217;ve made the video, you can delete all the individual png frame files to keep things tidy:</simpara>
<screen>$ rm *.png</screen>
</section>
</section>
</section>
<section xml:id="_wave_climates">
<title>Wave Climates</title>
<simpara>The model requires wave conditions to drive alongshore sediment transport. This is supplied in the form of a waveclimate object that the coastline model can interact with. For the purposes of this model, a wave climate consists of a timeseries of waves considered to be "offshore", that is to say the wave conditions recieved at the bottom of the shoreface. This time series comprises significant wave height <inlineequation><alt><![CDATA[H_0]]></alt><mathphrase><![CDATA[H_0]]></mathphrase></inlineequation>, wave period <inlineequation><alt><![CDATA[T]]></alt><mathphrase><![CDATA[T]]></mathphrase></inlineequation> and wave direction <inlineequation><alt><![CDATA[\theta_0]]></alt><mathphrase><![CDATA[\theta_0]]></mathphrase></inlineequation>. The waveclimate object can take a variety of guises, including both hypothetical and real wave climates. the model is most sensitive to variation in <emphasis>wave direction</emphasis>. Hypothetical wave climates include the U-A descripition of wave directions (Ashton &amp; Murray, 2006) or a simple Gaussian distribution (Hurst et al., 2015). Real wave climates read in a timeseries of <inlineequation><alt><![CDATA[H_0]]></alt><mathphrase><![CDATA[H_0]]></mathphrase></inlineequation>, <inlineequation><alt><![CDATA[T]]></alt><mathphrase><![CDATA[T]]></mathphrase></inlineequation> and <inlineequation><alt><![CDATA[\theta_0]]></alt><mathphrase><![CDATA[\theta_0]]></mathphrase></inlineequation> data that might be collected from a nearby wave buoy deployment, or generated by a coastal area model such as <link xl:href="http://fvcom.smast.umassd.edu/fvcom/">FVCOM</link> or <link xl:href="http://www.swan.tudelft.nl/">SWAN</link>.</simpara>
<section xml:id="_single_wave">
<title>Single wave</title>
<simpara>The <literal>Wave</literal> object describes a single wave, and contains the wave period <inlineequation><alt><![CDATA[T]]></alt><mathphrase><![CDATA[T]]></mathphrase></inlineequation>, height <inlineequation><alt><![CDATA[H_0]]></alt><mathphrase><![CDATA[H_0]]></mathphrase></inlineequation> and direction <inlineequation><alt><![CDATA[\theta_0]]></alt><mathphrase><![CDATA[\theta_0]]></mathphrase></inlineequation>. The single wave object can be used as the entire wave climate but is more commonly implemented as an object sampled from another distributed wave climate. An individual wave can be declared and used to sample a wave from an existing wave climate as seen here:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();</programlisting>
<simpara>A new single wave object may be sampled during the main model loop at the desired time step:</simpara>
<programlisting language="c++" linenumbering="unnumbered">while (Time &lt; EndTime)
{
  //Get a new wave?
  if (Time &gt; GetWaveTime)
  {
    MyWave = WaveClimate.Get_Wave();
    GetWaveTime += WaveTimeDelta/365.;
  }
  ...</programlisting>
</section>
<section xml:id="_gaussian_wave_climate">
<title>Gaussian wave climate</title>
<simpara>The <literal>GuassianWaveClimate</literal> object contains six parameters to describe distributions of Wave period <inlineequation><alt><![CDATA[T]]></alt><mathphrase><![CDATA[T]]></mathphrase></inlineequation>, Wave height <inlineequation><alt><![CDATA[H_0]]></alt><mathphrase><![CDATA[H_0]]></mathphrase></inlineequation>, and Wave direction <inlineequation><alt><![CDATA[\theta_0]]></alt><mathphrase><![CDATA[\theta_0]]></mathphrase></inlineequation>. In order to initialise the wave climate in a driver file, 6 variables must be declared, and values assigned:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//Declare parameter for wave conditions
double OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveDirection,
	OffshoreStDWaveDirection, OffshoreMeanWaveHeight, OffshoreStDWaveHeight;</programlisting>
<simpara>The wave climate is initialised by declaring a <literal>GuassianWaveClimate</literal> object called <literal>WaveClimate</literal> and passing these variables as input arguments in the correct order.</simpara>
<programlisting language="c++" linenumbering="unnumbered">// initialise the wave climate
GaussianWaveClimate WaveClimate = GaussianWaveClimate(OffshoreMeanWavePeriod,
	OffshoreStDWavePeriod, OffshoreMeanWaveDirection, OffshoreStDWaveDirection,
	OffshoreMeanWaveHeight, OffshoreStDWaveHeight);</programlisting>
<simpara>We then also declare an individual wave object. This holds the period, height and direction of an individual wave <literal>MyWave</literal> which we later pass to the coastline object in order to drive coastal evolution. We will sample a wave from <literal>WaveClimate</literal> and pass it to <literal>MyWave</literal></simpara>
<programlisting language="c++" linenumbering="unnumbered">// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();</programlisting>
<simpara>This last line should appear in the main model loop to select new waves at the chosen frequency:</simpara>
<programlisting language="c++" linenumbering="unnumbered">while (Time &lt; EndTime)
{
  //Get a new wave?
  if (Time &gt; GetWaveTime)
  {
    MyWave = WaveClimate.Get_Wave();
    GetWaveTime += WaveTimeDelta/365.;
  }
  ...</programlisting>
</section>
<section xml:id="_bimodal_wave_climate">
<title>Bimodal  wave climate</title>
<simpara>A bimodal wave climate can be created by using two other wave climate objects such as the Gaussian wave climate, and sampling between the two at random. To set up such a model, first declare two Gaussian wave climates with the chosen parameters:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Bimodal wave climate
//Wave climate 1
double OffshoreMeanWaveDirection1 = 45.;
double OffshoreStDWaveDirection1 = 20.;
double OffshoreMeanWavePeriod1 = 6.;
double OffshoreStDWavePeriod1 = 2.;
double OffshoreMeanWaveHeight1 = 0.8;
double OffshoreStDWaveHeight1 = 0.2;
GaussianWaveClimate WaveClimate1(OffshoreMeanWavePeriod1,OffshoreStDWavePeriod1,OffshoreMeanWaveDirection1,OffshoreStDWaveDirection1,OffshoreMeanWaveHeight1, OffshoreStDWaveHeight1);

//Wave climate 2
double OffshoreMeanWaveDirection2 = 140.;
double OffshoreStDWaveDirection2 = 20.;
double OffshoreMeanWavePeriod2 = 5.;
double OffshoreStDWavePeriod2 = 1.;
double OffshoreMeanWaveHeight2 = 1.1;
double OffshoreStDWaveHeight2 = 0.2;
GaussianWaveClimate WaveClimate2(OffshoreMeanWavePeriod2,OffshoreStDWavePeriod2,OffshoreMeanWaveDirection2,OffshoreStDWaveDirection2,OffshoreMeanWaveHeight2, OffshoreStDWaveHeight2);</programlisting>
<simpara>Then declare an individual wave object:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();</programlisting>
<simpara>In the main model loop we will use a random number generator to choose which of the two wave climates to select from. The fraction <literal>0.5</literal> dictates that we should sample roughly half of the waves from each wave climate. This could be adjusted if it was required that one mode should be more dominant.</simpara>
<programlisting language="c++" linenumbering="unnumbered">while (Time &lt; EndTime)
{
	//Get a new wave?
	if (Time &gt; GetWaveTime)
	{
		// Use a random sampler to chose between wave climates
		rand1 = (double)rand()/RAND_MAX;
		if (rand1 &lt; 0.5) MyWave = WaveClimate1.Get_Wave();
		else MyWave = WaveClimate2.Get_Wave();
		GetWaveTime += WaveTimeDelta/365.;
	}
	...</programlisting>
</section>
<section xml:id="_u_a_wave_climate">
<title>U-A wave climate</title>
<simpara>Ashton and Murray (2006) used a 4-bin directional wave climate to represent offshore waves that will interact with the coastline. This four-bin directional wave climate can be described by two parameters, wave direction highness <emphasis>U</emphasis> and asymmetry <emphasis>A</emphasis>:
* the fraction of waves that approach from high angle <emphasis>U</emphasis> (&gt;45<superscript>o</superscript> relative to the overall trend of the coastline)
* the fraction of waves that approach from the "left" <emphasis>A</emphasis> (i.e. up coast)</simpara>
<simpara>Here are some example plots of 4-binned wave climates and their associated <emphasis>U</emphasis> and <emphasis>A</emphasis> values to illustrate (after Thomas et al. 2016):</simpara>
<figure>
<title>Example 4-bin wave climates described by wave highness and asymmetry (<emphasis>U vs A</emphasis>) that produce capes and spits (Thomas et al. 2016).</title>
<mediaobject>
<imageobject>
<imagedata fileref="./images//UA_pdfs.png" contentwidth="500" align="center"/>
</imageobject>
<textobject><phrase>UA pdfs</phrase></textobject>
</mediaobject>
</figure>
<simpara>To declare the wave climate, we also need values for the mean and standard deviation for wave period latexmath:[T] and wave height latexmath:[H_0]. Thus we declare:</simpara>
<programlisting language="c++" linenumbering="unnumbered">double U = 0.55;
double A = 0.7;
double OffshoreMeanWavePeriod = 6.;
double OffshoreStDWavePeriod = 1.;
double OffshoreMeanWaveHeight = 1.;
double OffshoreStDWaveHeight = 1.;</programlisting>
<simpara>A <literal>UAWaveClimate</literal> object with <emphasis>U</emphasis> = 0.55 and <emphasis>A</emphasis> = 0.7 can then be declared and assigned to an object called <literal>WaveClimate</literal> by passing these variables:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//initialise wave climate
UAWaveClimate WaveClimate = UAWaveClimate(U, A, Trend, OffshoreMeanWavePeriod, OffshoreStDWavePeriod, OffshoreMeanWaveHeight, OffshoreStDWaveHeight);</programlisting>
<simpara>We then also declare an individual <literal>Wave</literal> object. This holds the period, height and direction of an individual wave <literal>MyWave</literal> which we later pass to the coastline object in order to drive coastal evolution. We will sample a wave from <literal>WaveClimate</literal> and pass it to <literal>MyWave</literal>:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();
// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();</programlisting>
<simpara>The last line will appear inside the main model loop in the driver file to select new waves at each or the specified model time step:</simpara>
<programlisting language="c++" linenumbering="unnumbered">while (Time &lt; EndTime)
{
  //Get a new wave?
  if (Time &gt; GetWaveTime)
  {
    MyWave = WaveClimate.Get_Wave();
    GetWaveTime += WaveTimeDelta/365.;
  }
  ...</programlisting>
</section>
<section xml:id="_real_wave_data">
<title>Real wave data</title>
<simpara>The model can be driven by wave data such as that taken from a wave buoy or supplied from an external wave model such as <link xl:href="http://fvcom.smast.umassd.edu/fvcom/">FVCOM</link> or <link xl:href="http://www.swan.tudelft.nl/">SWAN</link>. The required input parameters are offshore wave direction, period and height.</simpara>
<simpara>Input files should have a header line, and three data columns for direction, period and height.</simpara>
<screen>Headers
   Dir[0]    |    Period[0]    |    Height[0]
   Dir[1]    |    Period[1]    |    Height[1]
   Dir[2]    |    Period[2]    |    Height[2]
    ...      |       ...       |      ...
Dir[NoWaves] | Period[NoWaves] | Height[NoWaves]</screen>
<simpara>The model doesn&#8217;t read how frequent the data are, but the frequency with which the model samples this data can be set in a driver file. The data is read and sampled in the order provided.</simpara>
<simpara>The wave climate is initialised in a driver file by passing the input filename as a <literal>string</literal>:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// initialise the wave climate
WaveFileName = "MyWaveData.txt";
RealWaveClimate WaveClimate = RealWaveClimate(WaveFileName);</programlisting>
<simpara>An individual wave object will also be required:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// declare an individual wave (this will be sampled from the wave climate object
Wave MyWave = Wave();</programlisting>
<simpara>A wave is then sampled from the wave climate by assigning it the individual wave object:</simpara>
<programlisting language="c++" linenumbering="unnumbered">// Get a wave from the wave climate object
MyWave = WaveClimate.Get_Wave();</programlisting>
<simpara>Note that the model will proceed iteratively through the wave climate data until it reaches the end of the file, then will loop back to the beginning and keep going continously until the model run is ended.</simpara>
</section>
</section>
<section xml:id="_under_the_hood">
<title>Under the hood</title>
<simpara>This section still has a long way to go!</simpara>
<section xml:id="_initialising_a_coastline_object">
<title>Initialising a Coastline object</title>
<section xml:id="_read_a_coastline_from_file">
<title>Read a Coastline from file</title>
<simpara>Input files for the position of the coast take the same format as output files. The first line is a header containing integer values for the <literal>StartBoundary</literal> and <literal>EndBoundary</literal> conditions. The next two lines are the X and Y coordinates of the line respectively, but both preceded by the time (in years). We use \| to indicate a white space delimiter here such as a space or tab.</simpara>
<screen>StartBoundary | EndBoundary
Time | X[0] | X[1] | X[2] =====&gt; X[NoNodes]
Time | Y[0] | Y[1] | Y[2] =====&gt; Y[NoNodes]</screen>
<simpara>So for example, a 5 metre long coastline with fixed boundary conditions oriented at 135^o with a <inlineequation><alt><![CDATA[sqrt{2}]]></alt><mathphrase><![CDATA[sqrt{2}]]></mathphrase></inlineequation> node spacing, at <literal>Time = 0</literal> would have an input file:</simpara>
<screen>2 2
0 0 1 2 3 4 5
0 0 1 2 3 4 5</screen>
</section>
</section>
<section xml:id="_initialising_a_cliffline_object">
<title>Initialising a Cliffline object</title>

</section>
<section xml:id="_boundary_conditions_2">
<title>Boundary Conditions</title>
<simpara>The model is a single line. The start and end of the line can be handled in different ways. At the moment, we have two possible boundary conditions, which are assigned by setting the <literal>StartBoundary</literal> and <literal>EndBoundary</literal> parameters when initialising the coastline, or putting these in the header of an input file if initialising the coastline with an existing coastline output file (or real coastline). The boundary conditions are set by an integer as:
1. Periodic boundary conditions: the start of the line is also the end, and sediment can be passed \"round the back\" e.g. an island.
2. Fixed boundary conditions the first and last two nodes/cells in the model are fixed and immovable.</simpara>
</section>
<section xml:id="_writing_results_to_file">
<title>Writing results to file</title>
<simpara>The <literal>Coastline</literal> object writes the position of the coast to a text file with a name provided in the call <literal>WriteCoastFile</literal>. The <literal>Time</literal> must also be passed:</simpara>
<programlisting language="c++" linenumbering="unnumbered">//loop through time and evolve the coast
CoastVector.WriteCoast(WriteCoastFile, Time);</programlisting>
<simpara>The file format is the same as for reading a coast from a text file. The first line is a header containing integer values for the <literal>StartBoundary</literal> and <literal>EndBoundary</literal> conditions. The next two lines are the X and Y coordinates of the line respectively, but both preceded by the time (in years). We use \| to indicate a white space delimiter here such as a space or tab.</simpara>
<screen>StartBoundary | EndBoundary
Time | X[0] | X[1] | X[2] =====&gt; X[NoNodes]
Time | Y[0] | Y[1] | Y[2] =====&gt; Y[NoNodes]</screen>
<simpara>So for example, a 5 metre long coastline with fixed boundary conditions oriented at 135^o with a <inlineequation><alt><![CDATA[sqrt{2}]]></alt><mathphrase><![CDATA[sqrt{2}]]></mathphrase></inlineequation> node spacing, at <literal>Time = 1</literal>, that has not changed since <literal>Time = 0</literal> would have an input file:</simpara>
<screen>2 2
0 0 1 2 3 4 5
0 0 1 2 3 4 5
1 0 1 2 3 4 5
1 0 1 2 3 4 5</screen>
<simpara>More details to follow. See the [Doxygen documentation] for the time being.</simpara>
</section>
</section>
<section xml:id="_ensemble_mode">
<title>Ensemble mode</title>
<simpara>Details to follow.</simpara>
</section>
<section xml:id="_references">
<title>References</title>
<simpara><phrase role="small">Ashton, A. D., and A. B. Murray (2006), High-angle wave instability and emergent shoreline shapes: 1. Modeling of sand waves, flying spits, and capes, <emphasis>J. Geophys. Res.</emphasis>,
111, F04011, doi: <link xl:href="http://dx.doi.org/10.1029/2005JF000422">10.1029/2005JF000422</link>.</phrase></simpara>
<simpara><phrase role="small">Barkwith, A., Thomas, C. W., Limber, P. W., Ellis, M. A., and Murray, A. B. (2014a), Coastal vulnerability of a pinned, soft-cliff coastline – Part I: Assessing the natural sensitivity to wave climate, <emphasis>Earth Surf. Dynam.</emphasis>, 2, 295-308, doi: <link xl:href="http://dx.doi.org/10.5194/esurf-2-295-2014">10.5194/esurf-2-295-2014</link>.</phrase></simpara>
<simpara><phrase role="small">Barkwith, A., Hurst, M. D., Thomas, C. W., Ellis, M. A., Limber, P. L., and Murray, A. B. (2014b) Coastal vulnerability of a pinned, soft-cliff coastline, II: assessing the influence of sea walls on future morphology, <emphasis>Earth Surf. Dynam.</emphasis>, 2, 233-242, doi: <link xl:href="http://dx.doi.org/10.5194/esurf-2-233-2014">10.5194/esurf-2-233-2014</link>.</phrase></simpara>
<simpara><phrase role="small">Brooks, S. M., and T. Spencer (2010), Temporal and spatial variations in recession rates and sediment release from soft rock cliffs, Suffolk coast, UK, <emphasis>Geomorph.</emphasis>, 124, 26-41, doi: <link xl:href="http://dx.doi.org/10.1016/j.geomorph.2010.08.005">10.1016/j.geomorph.2010.08.005</link>.</phrase></simpara>
<simpara><phrase role="small">Hurst, M. D., A. Barkwith, M. A. Ellis, C. W. Thomas, and A. B. Murray (2015), Exploring the sensitivities of crenulate bay shorelines to wave climates using a new vector-based one-line model, <emphasis>J. Geophys. Res. Earth Surf.</emphasis>, 120, 2586–2608, doi: <link xl:href="http://dx.doi.org/10.1002/2015JF003704">10.1002/2015JF003704</link>.</phrase></simpara>
<simpara><phrase role="small">Limber, P. W. and A. Brad Murray (2011) Beach and sea-cliff dynamics as a driver of long-term rocky coastline evolution and stability, <emphasis>Geology</emphasis>, 39, 1147-1150, doi: <link xl:href="http://dx.doi.org/10.1130/G32315.1">10.1130/G32315.1</link></phrase></simpara>
<simpara><phrase role="small">Thomas, C. W., Murray, A. B., Ashton, A. D., Hurst, M. D., Barkwith, A. K. A. P., and Ellis, M. A. (2016), Complex coastlines responding to climate change: do shoreline shapes reflect present forcing or "remember" the distant past?, Earth Surf. Dynam. Discuss., doi: <link xl:href="http://dx.doi.org/10.5194/esurf-2016-35">10.5194/esurf-2016-35</link>, <emphasis>in review</emphasis>.</phrase></simpara>
<simpara><phrase role="small">Valvo, L. M., A. B. Murray, and A. Ashton (2006), How does underlying geology affect coastline change? An initial modeling investigation, <emphasis>J. Geophys. Res.</emphasis>, 111, F02025, doi: <link xl:href="http://dx.doi.org/10.1029/2005JF000340">10.1029/2005JF000340</link></phrase></simpara>
</section>
</article>